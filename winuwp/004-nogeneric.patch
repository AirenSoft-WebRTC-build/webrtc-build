diff --git a/call/rtp_payload_params.cc b/call/rtp_payload_params.cc
index 33e9c7666e..dcd0da8650 100644
--- a/call/rtp_payload_params.cc
+++ b/call/rtp_payload_params.cc
@@ -316,7 +316,7 @@ void RtpPayloadParams::SetGeneric(const CodecSpecificInfo* codec_specific_info,
       chains_calculator_.Reset(
           codec_specific_info->generic_frame_info->part_of_chain);
     }
-    rtp_video_header->generic = GenericDescriptorFromFrameInfo(
+    rtp_video_header->generic_ = GenericDescriptorFromFrameInfo(
         *codec_specific_info->generic_frame_info, frame_id);
     return;
   }
@@ -420,7 +420,7 @@ void RtpPayloadParams::GenericToGeneric(int64_t frame_id,
                                         bool is_keyframe,
                                         RTPVideoHeader* rtp_video_header) {
   RTPVideoHeader::GenericDescriptorInfo& generic =
-      rtp_video_header->generic.emplace();
+      rtp_video_header->generic_.emplace();
 
   generic.frame_id = frame_id;
   generic.decode_target_indications.push_back(DecodeTargetIndication::kSwitch);
@@ -453,7 +453,7 @@ void RtpPayloadParams::H264ToGeneric(const CodecSpecificInfoH264& h264_info,
   }
 
   RTPVideoHeader::GenericDescriptorInfo& generic =
-      rtp_video_header->generic.emplace();
+      rtp_video_header->generic_.emplace();
 
   generic.frame_id = frame_id;
   generic.temporal_index = temporal_index;
@@ -509,7 +509,7 @@ void RtpPayloadParams::Vp8ToGeneric(const CodecSpecificInfoVP8& vp8_info,
   }
 
   RTPVideoHeader::GenericDescriptorInfo& generic =
-      rtp_video_header->generic.emplace();
+      rtp_video_header->generic_.emplace();
 
   generic.frame_id = frame_id;
   generic.spatial_index = spatial_index;
@@ -578,7 +578,7 @@ void RtpPayloadParams::Vp9ToGeneric(const CodecSpecificInfoVP9& vp9_info,
   }
 
   RTPVideoHeader::GenericDescriptorInfo& result =
-      rtp_video_header.generic.emplace();
+      rtp_video_header.generic_.emplace();
 
   result.frame_id = frame_id;
   result.spatial_index = spatial_index;
@@ -643,7 +643,7 @@ void RtpPayloadParams::Vp9ToGeneric(const CodecSpecificInfoVP9& vp9_info,
     // non-layerd streams.
     if (spatial_index > 0 || temporal_index > 0) {
       // Prefer to generate no generic layering than an inconsistent one.
-      rtp_video_header.generic.reset();
+      rtp_video_header.generic_.reset();
       return;
     }
 
diff --git a/modules/rtp_rtcp/source/rtp_descriptor_authentication.cc b/modules/rtp_rtcp/source/rtp_descriptor_authentication.cc
index f4525f0db1..eadbae52eb 100644
--- a/modules/rtp_rtcp/source/rtp_descriptor_authentication.cc
+++ b/modules/rtp_rtcp/source/rtp_descriptor_authentication.cc
@@ -21,11 +21,11 @@ namespace webrtc {
 
 std::vector<uint8_t> RtpDescriptorAuthentication(
     const RTPVideoHeader& rtp_video_header) {
-  if (!rtp_video_header.generic) {
+  if (!rtp_video_header.generic_) {
     return {};
   }
   const RTPVideoHeader::GenericDescriptorInfo& descriptor =
-      *rtp_video_header.generic;
+      *rtp_video_header.generic_;
   // Default way of creating additional data for an encrypted frame.
   if (descriptor.spatial_index < 0 || descriptor.temporal_index < 0 ||
       descriptor.spatial_index >=
diff --git a/modules/rtp_rtcp/source/rtp_sender_video.cc b/modules/rtp_rtcp/source/rtp_sender_video.cc
index ebca7aaa75..ce5e224a9f 100644
--- a/modules/rtp_rtcp/source/rtp_sender_video.cc
+++ b/modules/rtp_rtcp/source/rtp_sender_video.cc
@@ -121,9 +121,9 @@ absl::optional<VideoPlayoutDelay> LoadVideoPlayoutDelayOverride(
 bool PacketWillLikelyBeRequestedForRestransmissionIfLost(
     const RTPVideoHeader& video_header) {
   return IsBaseLayer(video_header) &&
-         !(video_header.generic.has_value()
+         !(video_header.generic_.has_value()
                ? absl::c_linear_search(
-                     video_header.generic->decode_target_indications,
+                     video_header.generic_->decode_target_indications,
                      DecodeTargetIndication::kDiscardable)
                : false);
 }
@@ -358,26 +358,26 @@ void RTPSenderVideo::AddRtpHeaderExtensions(const RTPVideoHeader& video_header,
         *video_header.absolute_capture_time);
   }
 
-  if (video_header.generic) {
+  if (video_header.generic_) {
     bool extension_is_set = false;
     if (packet->IsRegistered<RtpDependencyDescriptorExtension>() &&
         video_structure_ != nullptr) {
       DependencyDescriptor descriptor;
       descriptor.first_packet_in_frame = first_packet;
       descriptor.last_packet_in_frame = last_packet;
-      descriptor.frame_number = video_header.generic->frame_id & 0xFFFF;
+      descriptor.frame_number = video_header.generic_->frame_id & 0xFFFF;
       descriptor.frame_dependencies.spatial_id =
-          video_header.generic->spatial_index;
+          video_header.generic_->spatial_index;
       descriptor.frame_dependencies.temporal_id =
-          video_header.generic->temporal_index;
-      for (int64_t dep : video_header.generic->dependencies) {
+          video_header.generic_->temporal_index;
+      for (int64_t dep : video_header.generic_->dependencies) {
         descriptor.frame_dependencies.frame_diffs.push_back(
-            video_header.generic->frame_id - dep);
+            video_header.generic_->frame_id - dep);
       }
       descriptor.frame_dependencies.chain_diffs =
-          video_header.generic->chain_diffs;
+          video_header.generic_->chain_diffs;
       descriptor.frame_dependencies.decode_target_indications =
-          video_header.generic->decode_target_indications;
+          video_header.generic_->decode_target_indications;
       RTC_DCHECK_EQ(
           descriptor.frame_dependencies.decode_target_indications.size(),
           video_structure_->num_decode_targets);
@@ -392,7 +392,7 @@ void RTPSenderVideo::AddRtpHeaderExtensions(const RTPVideoHeader& video_header,
       // layers when inter layer dependency is not used, i.e. S structures.
       // Distinguish these two cases by checking if there are any dependencies.
       if (video_header.frame_type == VideoFrameType::kVideoFrameKey &&
-          video_header.generic->dependencies.empty() && first_packet) {
+          video_header.generic_->dependencies.empty() && first_packet) {
         // To avoid extra structure copy, temporary share ownership of the
         // video_structure with the dependency descriptor.
         descriptor.attached_structure =
@@ -415,17 +415,17 @@ void RTPSenderVideo::AddRtpHeaderExtensions(const RTPVideoHeader& video_header,
 
       if (first_packet) {
         generic_descriptor.SetFrameId(
-            static_cast<uint16_t>(video_header.generic->frame_id));
-        for (int64_t dep : video_header.generic->dependencies) {
+            static_cast<uint16_t>(video_header.generic_->frame_id));
+        for (int64_t dep : video_header.generic_->dependencies) {
           generic_descriptor.AddFrameDependencyDiff(
-              video_header.generic->frame_id - dep);
+              video_header.generic_->frame_id - dep);
         }
 
-        uint8_t spatial_bitmask = 1 << video_header.generic->spatial_index;
+        uint8_t spatial_bitmask = 1 << video_header.generic_->spatial_index;
         generic_descriptor.SetSpatialLayersBitmask(spatial_bitmask);
 
         generic_descriptor.SetTemporalLayer(
-            video_header.generic->temporal_index);
+            video_header.generic_->temporal_index);
 
         if (video_header.frame_type == VideoFrameType::kVideoFrameKey) {
           generic_descriptor.SetResolution(video_header.width,
@@ -504,12 +504,12 @@ bool RTPSenderVideo::SendVideo(int payload_type,
     }
   }
 
-  if (video_structure_ != nullptr && video_header.generic) {
+  if (video_structure_ != nullptr && video_header.generic_) {
     active_decode_targets_tracker_.OnFrame(
         video_structure_->decode_target_protected_by_chain,
-        video_header.generic->active_decode_targets,
+        video_header.generic_->active_decode_targets,
         video_header.frame_type == VideoFrameType::kVideoFrameKey,
-        video_header.generic->frame_id, video_header.generic->chain_diffs);
+        video_header.generic_->frame_id, video_header.generic_->chain_diffs);
   }
 
   // No FEC protection for upper temporal layers, if used.
diff --git a/modules/rtp_rtcp/source/rtp_video_header.cc b/modules/rtp_rtcp/source/rtp_video_header.cc
index b07a7beec4..16b1c94a74 100644
--- a/modules/rtp_rtcp/source/rtp_video_header.cc
+++ b/modules/rtp_rtcp/source/rtp_video_header.cc
@@ -36,12 +36,12 @@ VideoFrameMetadata RTPVideoHeader::GetAsMetadata() const {
   metadata.SetHeight(height);
   metadata.SetRotation(rotation);
   metadata.SetContentType(content_type);
-  if (generic) {
-    metadata.SetFrameId(generic->frame_id);
-    metadata.SetSpatialIndex(generic->spatial_index);
-    metadata.SetTemporalIndex(generic->temporal_index);
-    metadata.SetFrameDependencies(generic->dependencies);
-    metadata.SetDecodeTargetIndications(generic->decode_target_indications);
+  if (generic_) {
+    metadata.SetFrameId(generic_->frame_id);
+    metadata.SetSpatialIndex(generic_->spatial_index);
+    metadata.SetTemporalIndex(generic_->temporal_index);
+    metadata.SetFrameDependencies(generic_->dependencies);
+    metadata.SetDecodeTargetIndications(generic_->decode_target_indications);
   }
   metadata.SetIsLastFrameInPicture(is_last_frame_in_picture);
   metadata.SetSimulcastIdx(simulcastIdx);
@@ -73,15 +73,15 @@ void RTPVideoHeader::SetFromMetadata(const VideoFrameMetadata& metadata) {
   rotation = metadata.GetRotation();
   content_type = metadata.GetContentType();
   if (!metadata.GetFrameId().has_value()) {
-    generic = absl::nullopt;
+    generic_ = absl::nullopt;
   } else {
-    generic.emplace();
-    generic->frame_id = metadata.GetFrameId().value();
-    generic->spatial_index = metadata.GetSpatialIndex();
-    generic->temporal_index = metadata.GetTemporalIndex();
-    generic->dependencies.assign(metadata.GetFrameDependencies().begin(),
+    generic_.emplace();
+    generic_->frame_id = metadata.GetFrameId().value();
+    generic_->spatial_index = metadata.GetSpatialIndex();
+    generic_->temporal_index = metadata.GetTemporalIndex();
+    generic_->dependencies.assign(metadata.GetFrameDependencies().begin(),
                                  metadata.GetFrameDependencies().end());
-    generic->decode_target_indications.assign(
+    generic_->decode_target_indications.assign(
         metadata.GetDecodeTargetIndications().begin(),
         metadata.GetDecodeTargetIndications().end());
   }
diff --git a/modules/rtp_rtcp/source/rtp_video_header.h b/modules/rtp_rtcp/source/rtp_video_header.h
index d185c20c83..57e5627466 100644
--- a/modules/rtp_rtcp/source/rtp_video_header.h
+++ b/modules/rtp_rtcp/source/rtp_video_header.h
@@ -69,7 +69,7 @@ struct RTPVideoHeader {
   VideoFrameMetadata GetAsMetadata() const;
   void SetFromMetadata(const VideoFrameMetadata& metadata);
 
-  absl::optional<GenericDescriptorInfo> generic;
+  absl::optional<GenericDescriptorInfo> generic_;
 
   VideoFrameType frame_type = VideoFrameType::kEmptyFrame;
   uint16_t width = 0;
diff --git a/modules/video_coding/packet_buffer.cc b/modules/video_coding/packet_buffer.cc
index 52ef5c2d85..0dc71c7029 100644
--- a/modules/video_coding/packet_buffer.cc
+++ b/modules/video_coding/packet_buffer.cc
@@ -256,7 +256,7 @@ std::vector<std::unique_ptr<PacketBuffer::Packet>> PacketBuffer::FindFrames(
       int64_t frame_timestamp = buffer_[start_index]->timestamp;
 
       // Identify H.264 keyframes by means of SPS, PPS, and IDR.
-      bool is_generic = buffer_[start_index]->video_header.generic.has_value();
+      bool is_generic = buffer_[start_index]->video_header.generic_.has_value();
       bool is_h264_descriptor =
           (buffer_[start_index]->codec() == kVideoCodecH264) && !is_generic;
       bool has_h264_sps = false;
diff --git a/modules/video_coding/rtp_frame_reference_finder.cc b/modules/video_coding/rtp_frame_reference_finder.cc
index a44b76bf15..695e161ba6 100644
--- a/modules/video_coding/rtp_frame_reference_finder.cc
+++ b/modules/video_coding/rtp_frame_reference_finder.cc
@@ -48,9 +48,9 @@ RtpFrameReferenceFinder::ReturnVector RtpFrameReferenceFinderImpl::ManageFrame(
     std::unique_ptr<RtpFrameObject> frame) {
   const RTPVideoHeader& video_header = frame->GetRtpVideoHeader();
 
-  if (video_header.generic.has_value()) {
+  if (video_header.generic_.has_value()) {
     return GetRefFinderAs<RtpGenericFrameRefFinder>().ManageFrame(
-        std::move(frame), *video_header.generic);
+        std::move(frame), *video_header.generic_);
   }
 
   switch (frame->codec_type()) {
diff --git a/video/rtp_video_stream_receiver2.cc b/video/rtp_video_stream_receiver2.cc
index e875a5e109..fffcf92bcb 100644
--- a/video/rtp_video_stream_receiver2.cc
+++ b/video/rtp_video_stream_receiver2.cc
@@ -433,7 +433,7 @@ RtpVideoStreamReceiver2::ParseGenericDependenciesExtension(
     video_header->is_last_packet_in_frame =
         dependency_descriptor.last_packet_in_frame;
 
-    auto& generic_descriptor_info = video_header->generic.emplace();
+    auto& generic_descriptor_info = video_header->generic_.emplace();
     generic_descriptor_info.frame_id = frame_id;
     generic_descriptor_info.spatial_index =
         dependency_descriptor.frame_dependencies.spatial_id;
@@ -490,7 +490,7 @@ RtpVideoStreamReceiver2::ParseGenericDependenciesExtension(
             ? VideoFrameType::kVideoFrameKey
             : VideoFrameType::kVideoFrameDelta;
 
-    auto& generic_descriptor_info = video_header->generic.emplace();
+    auto& generic_descriptor_info = video_header->generic_.emplace();
     int64_t frame_id =
         frame_id_unwrapper_.Unwrap(generic_frame_descriptor.FrameId());
     generic_descriptor_info.frame_id = frame_id;
@@ -620,12 +620,12 @@ bool RtpVideoStreamReceiver2::OnReceivedPayloadData(
                              "frame descriptor, but it is missing.";
     } else {
       if (video_header.is_first_packet_in_frame) {
-        RTC_DCHECK(video_header.generic);
+        RTC_DCHECK(video_header.generic_);
         LossNotificationController::FrameDetails frame;
         frame.is_keyframe =
             video_header.frame_type == VideoFrameType::kVideoFrameKey;
-        frame.frame_id = video_header.generic->frame_id;
-        frame.frame_dependencies = video_header.generic->dependencies;
+        frame.frame_id = video_header.generic_->frame_id;
+        frame.frame_dependencies = video_header.generic_->dependencies;
         loss_notification_controller_->OnReceivedPacket(
             rtp_packet.SequenceNumber(), &frame);
       } else {
@@ -838,7 +838,7 @@ void RtpVideoStreamReceiver2::OnAssembledFrame(
   RTC_DCHECK(frame);
 
   const absl::optional<RTPVideoHeader::GenericDescriptorInfo>& descriptor =
-      frame->GetRtpVideoHeader().generic;
+      frame->GetRtpVideoHeader().generic_;
 
   if (loss_notification_controller_ && descriptor) {
     loss_notification_controller_->OnAssembledFrame(
