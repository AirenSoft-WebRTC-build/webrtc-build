diff --git a/sdk/objc/api/peerconnection/RTCEncodedImage+Private.mm b/sdk/objc/api/peerconnection/RTCEncodedImage+Private.mm
index c8936d3..44d99fa 100644
--- a/sdk/objc/api/peerconnection/RTCEncodedImage+Private.mm
+++ b/sdk/objc/api/peerconnection/RTCEncodedImage+Private.mm
@@ -95,6 +95,13 @@ class ObjCEncodedImageBuffer : public webrtc::EncodedImageBufferInterface {
     self.contentType = (encodedImage.content_type_ == webrtc::VideoContentType::SCREENSHARE) ?
         RTCVideoContentTypeScreenshare :
         RTCVideoContentTypeUnspecified;
+#ifdef RTC_ENABLE_BFRAME
+    self.isBframe = encodedImage.IsBFrame().has_value() ? @(encodedImage.IsBFrame().value()) : nil;
+    self.dts = self.isBframe ? @(encodedImage.Dts().value_or(encodedImage.RtpTimestamp())) : nil;
+#else // RTC_ENABLE_BFRAME
+    self.isBframe = nil;
+    self.dts = nil;
+#endif // RTC_ENABLE_BFRAME
   }
 
   return self;
@@ -124,6 +131,16 @@ class ObjCEncodedImageBuffer : public webrtc::EncodedImageBufferInterface {
       webrtc::VideoContentType::SCREENSHARE :
       webrtc::VideoContentType::UNSPECIFIED;
 
+#ifdef RTC_ENABLE_BFRAME
+  if (self.dts) {
+    encodedImage.SetDts(self.dts.unsignedIntValue);
+  }
+  
+  if (self.isBframe) {
+    encodedImage.SetBFrame(self.isBframe.boolValue ? true : false);
+  }
+#endif // RTC_ENABLE_BFRAME
+
   return encodedImage;
 }
 
diff --git a/sdk/objc/api/peerconnection/RTCVideoCodecInfo+Private.mm b/sdk/objc/api/peerconnection/RTCVideoCodecInfo+Private.mm
index 57d5847..706bb23 100644
--- a/sdk/objc/api/peerconnection/RTCVideoCodecInfo+Private.mm
+++ b/sdk/objc/api/peerconnection/RTCVideoCodecInfo+Private.mm
@@ -12,6 +12,10 @@
 
 #import "helpers/NSString+StdString.h"
 
+#ifdef RTC_ENABLE_BFRAME
+# import "rtc_base/logging.h"
+#endif // RTC_ENABLE_BFRAME
+
 @implementation RTC_OBJC_TYPE (RTCVideoCodecInfo)
 (Private)
 
@@ -30,9 +34,17 @@
     }
   }
 
+#ifdef RTC_ENABLE_BFRAME
+  RTC_LOG(LS_INFO) << "Initializing RTCVideoCodecInfo with bframe_enabled: " << format.bframe_enabled;
+  return [self initWithName:[NSString stringForStdString:format.name]
+                 parameters:params
+           scalabilityModes:scalabilityModes
+               enableBframe:format.bframe_enabled];
+#else // RTC_ENABLE_BFRAME
   return [self initWithName:[NSString stringForStdString:format.name]
                  parameters:params
            scalabilityModes:scalabilityModes];
+#endif // RTC_ENABLE_BFRAME
 }
 
 - (webrtc::SdpVideoFormat)nativeSdpVideoFormat {
@@ -49,7 +61,15 @@
     scalabilityModes.push_back(static_cast<webrtc::ScalabilityMode>(value));
   }
 
+#ifdef RTC_ENABLE_BFRAME
+  auto format = webrtc::SdpVideoFormat([NSString stdStringForString:self.name], parameters, scalabilityModes);
+
+  format.bframe_enabled = self.bframeEnabled;
+
+  return format;
+#else // RTC_ENABLE_BFRAME
   return webrtc::SdpVideoFormat([NSString stdStringForString:self.name], parameters, scalabilityModes);
+#endif // RTC_ENABLE_BFRAME
 }
 
 @end
diff --git a/sdk/objc/api/peerconnection/RTCVideoEncoderSettings+Private.mm b/sdk/objc/api/peerconnection/RTCVideoEncoderSettings+Private.mm
index dec3a61..f571235 100644
--- a/sdk/objc/api/peerconnection/RTCVideoEncoderSettings+Private.mm
+++ b/sdk/objc/api/peerconnection/RTCVideoEncoderSettings+Private.mm
@@ -29,6 +29,23 @@
       self.maxFramerate = videoCodec->maxFramerate;
       self.qpMax = videoCodec->qpMax;
       self.mode = (RTCVideoCodecMode)videoCodec->mode;
+
+#ifdef RTC_ENABLE_BFRAME
+      switch (videoCodec->codecType) {
+        case webrtc::VideoCodecType::kVideoCodecH264:
+          self.bframeEnabled = videoCodec->H264().bframe_enabled;
+          break;
+          
+# ifdef RTC_ENABLE_H265
+        case webrtc::VideoCodecType::kVideoCodecH265:
+          self.bframeEnabled = videoCodec->H265().bframe_enabled;
+          break;
+# endif // RTC_ENABLE_H265
+        default:
+          self.bframeEnabled = false;
+          break;
+      }
+#endif // RTC_ENABLE_BFRAME
     }
   }
 
@@ -46,6 +63,13 @@
   videoCodec.qpMax = self.qpMax;
   videoCodec.mode = (webrtc::VideoCodecMode)self.mode;
 
+#ifdef RTC_ENABLE_BFRAME
+  videoCodec.H264()->bframe_enabled = self.bframeEnabled;
+# ifdef RTC_ENABLE_H265
+  videoCodec.H265()->bframe_enabled = self.bframeEnabled;
+# endif // RTC_ENABLE_H265
+#endif // RTC_ENABLE_BFRAME
+
   return videoCodec;
 }
 
diff --git a/sdk/objc/base/RTCEncodedImage.h b/sdk/objc/base/RTCEncodedImage.h
index 28529e5..3f56797 100644
--- a/sdk/objc/base/RTCEncodedImage.h
+++ b/sdk/objc/base/RTCEncodedImage.h
@@ -47,6 +47,13 @@ RTC_OBJC_EXPORT
 @property(nonatomic, strong) NSNumber *qp;
 @property(nonatomic, assign) RTCVideoContentType contentType;
 
+//START:RTC_ENABLE_BFRAME
+// uint32_t
+@property(nonatomic, assign) NSNumber *dts;
+// BOOL
+@property(nonatomic, assign) NSNumber *isBframe;
+//END:RTC_ENABLE_BFRAME
+
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/sdk/objc/base/RTCEncodedImage.m b/sdk/objc/base/RTCEncodedImage.m
index ad8441a..8ae4cd9 100644
--- a/sdk/objc/base/RTCEncodedImage.m
+++ b/sdk/objc/base/RTCEncodedImage.m
@@ -26,4 +26,9 @@
 @synthesize qp = _qp;
 @synthesize contentType = _contentType;
 
+//START:RTC_ENABLE_BFRAME
+@synthesize isBframe = _isBframe;
+@synthesize dts = _dts;
+//END:RTC_ENABLE_BFRAME
+
 @end
diff --git a/sdk/objc/base/RTCVideoCodecInfo.h b/sdk/objc/base/RTCVideoCodecInfo.h
index 40e5cac..5eaa8aa 100644
--- a/sdk/objc/base/RTCVideoCodecInfo.h
+++ b/sdk/objc/base/RTCVideoCodecInfo.h
@@ -57,21 +57,43 @@ RTC_OBJC_EXPORT
 
 - (instancetype)init NS_UNAVAILABLE;
 
+#ifdef RTC_ENABLE_BFRAME
+- (instancetype)initWithName:(NSString *)name
+                enableBframe:(BOOL)enabled;
+#endif // RTC_ENABLE_BFRAME
 - (instancetype)initWithName:(NSString *)name;
 
+#ifdef RTC_ENABLE_BFRAME
+- (instancetype)initWithName:(NSString *)name
+                  parameters:(nullable NSDictionary<NSString *, NSString *> *)parameters
+                enableBframe:(BOOL)enabled;
+#endif // RTC_ENABLE_BFRAME
 - (instancetype)initWithName:(NSString *)name
                   parameters:(nullable NSDictionary<NSString *, NSString *> *)parameters;
+#ifdef RTC_ENABLE_BFRAME
+- (instancetype)initWithName:(NSString *)name
+                  parameters:(nullable NSDictionary<NSString *, NSString *> *)parameters
+            scalabilityModes:(nullable NSArray<NSNumber *> *)scalabilityModes
+                enableBframe:(BOOL)enabled;
+#endif // RTC_ENABLE_BFRAME
 - (instancetype)initWithName:(NSString *)name
                   parameters:(nullable NSDictionary<NSString *, NSString *> *)parameters
             scalabilityModes:(nullable NSArray<NSNumber *> *)scalabilityModes
     NS_DESIGNATED_INITIALIZER;
 
 - (BOOL)isEqualToCodecInfo:(RTC_OBJC_TYPE(RTCVideoCodecInfo) *)info;
+#ifdef RTC_ENABLE_BFRAME
+- (BOOL)isEqualToCodecInfoWithoutBframe:(RTC_OBJC_TYPE(RTCVideoCodecInfo) *)info;
+#endif // RTC_ENABLE_BFRAME
 
 @property(nonatomic, readonly) NSString *name;
 @property(nonatomic, readonly) NSDictionary<NSString *, NSString *> *parameters;
 @property(nonatomic, readonly) NSArray<NSNumber *> *scalabilityModes;
 
+//START:RTC_ENABLE_BFRAME
+@property(nonatomic, readonly) BOOL bframeEnabled;
+//END:RTC_ENABLE_BFRAME
+
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/sdk/objc/base/RTCVideoCodecInfo.m b/sdk/objc/base/RTCVideoCodecInfo.m
index 1c41dee..b17a5e9 100644
--- a/sdk/objc/base/RTCVideoCodecInfo.m
+++ b/sdk/objc/base/RTCVideoCodecInfo.m
@@ -16,15 +16,39 @@
 @synthesize parameters = _parameters;
 @synthesize scalabilityModes = _scalabilityModes;
 
+#ifdef RTC_ENABLE_BFRAME
+- (instancetype)initWithName:(NSString *)name
+                enableBframe:(BOOL)enabled {
+  return [self initWithName:name parameters:nil enableBframe:enabled];
+}
+#endif
 - (instancetype)initWithName:(NSString *)name {
   return [self initWithName:name parameters:nil];
 }
 
+#ifdef RTC_ENABLE_BFRAME
+- (instancetype)initWithName:(NSString *)name
+                  parameters:(nullable NSDictionary<NSString *, NSString *> *)parameters
+                enableBframe:(BOOL)enabled {
+  return [self initWithName:name parameters:parameters scalabilityModes:nil enableBframe:enabled];
+}
+#endif
 - (instancetype)initWithName:(NSString *)name
                   parameters:(nullable NSDictionary<NSString *, NSString *> *)parameters {
   return [self initWithName:name parameters:parameters scalabilityModes:nil];
 }
 
+#ifdef RTC_ENABLE_BFRAME
+- (instancetype)initWithName:(NSString *)name
+                  parameters:(nullable NSDictionary<NSString *, NSString *> *)parameters
+            scalabilityModes:(nullable NSArray<NSNumber *> *)scalabilityModes
+                enableBframe:(BOOL)enabled {
+  if (self = [self initWithName:name parameters:parameters scalabilityModes:scalabilityModes]) {
+    _bframeEnabled = enabled;
+  }
+  return self;
+}
+#endif // RTC_ENABLE_BFRAME
 - (instancetype)initWithName:(NSString *)name
                   parameters:(nullable NSDictionary<NSString *, NSString *> *)parameters
             scalabilityModes:(nullable NSArray<NSNumber *> *)scalabilityModes {
@@ -32,12 +56,30 @@
     _name = name;
     _parameters = (parameters ? parameters : @{});
     _scalabilityModes = (scalabilityModes ? scalabilityModes : @[]);
+    //START:RTC_ENABLE_BFRAME
+    _bframeEnabled = false;
+    //END:RTC_ENABLE_BFRAME
   }
   return self;
 }
 
 
 - (BOOL)isEqualToCodecInfo:(RTC_OBJC_TYPE(RTCVideoCodecInfo) *)info {
+  if (!info ||
+      ![self.name isEqualToString:info.name] ||
+#ifdef RTC_ENABLE_BFRAME
+      ![self.parameters isEqualToDictionary:info.parameters] ||
+      self.bframeEnabled != info.bframeEnabled) {
+#else // RTC_ENABLE_BFRAME
+      ![self.parameters isEqualToDictionary:info.parameters]) {
+#endif // RTC_ENABLE_BFRAME
+    return NO;
+  }
+  return YES;
+}
+
+#ifdef RTC_ENABLE_BFRAME
+- (BOOL)isEqualToCodecInfoWithoutBframe:(RTC_OBJC_TYPE(RTCVideoCodecInfo) *)info {
   if (!info ||
       ![self.name isEqualToString:info.name] ||
       ![self.parameters isEqualToDictionary:info.parameters]) {
@@ -45,6 +87,7 @@
   }
   return YES;
 }
+#endif // RTC_ENABLE_BFRAME
 
 - (BOOL)isEqual:(id)object {
   if (self == object)
@@ -62,12 +105,20 @@
 
 - (instancetype)initWithCoder:(NSCoder *)decoder {
   return [self initWithName:[decoder decodeObjectForKey:@"name"]
+#ifdef RTC_ENABLE_BFRAME
+                 parameters:[decoder decodeObjectForKey:@"parameters"]
+               enableBframe:[[decoder decodeObjectForKey:@"bframeEnabled"] boolValue]];
+#else // RTC_ENABLE_BFRAME
                  parameters:[decoder decodeObjectForKey:@"parameters"]];
+#endif // RTC_ENABLE_BFRAME
 }
 
 - (void)encodeWithCoder:(NSCoder *)encoder {
   [encoder encodeObject:_name forKey:@"name"];
   [encoder encodeObject:_parameters forKey:@"parameters"];
+#ifdef RTC_ENABLE_BFRAME
+  [encoder encodeObject:@(_bframeEnabled) forKey:@"bframeEnabled"];
+#endif
 }
 
 @end
diff --git a/sdk/objc/base/RTCVideoEncoderSettings.h b/sdk/objc/base/RTCVideoEncoderSettings.h
index ae792ea..4956b2b 100644
--- a/sdk/objc/base/RTCVideoEncoderSettings.h
+++ b/sdk/objc/base/RTCVideoEncoderSettings.h
@@ -37,6 +37,10 @@ RTC_OBJC_EXPORT
 @property(nonatomic, assign) unsigned int qpMax;
 @property(nonatomic, assign) RTCVideoCodecMode mode;
 
+//START:RTC_ENABLE_BFRAME
+@property(nonatomic, assign) BOOL bframeEnabled;
+//END:RTC_ENABLE_BFRAME
+
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/sdk/objc/base/RTCVideoEncoderSettings.m b/sdk/objc/base/RTCVideoEncoderSettings.m
index f66cd2c..ac71a99 100644
--- a/sdk/objc/base/RTCVideoEncoderSettings.m
+++ b/sdk/objc/base/RTCVideoEncoderSettings.m
@@ -22,4 +22,8 @@
 @synthesize qpMax = _qpMax;
 @synthesize mode = _mode;
 
+//START:RTC_ENABLE_BFRAME
+@synthesize bframeEnabled = _bframeEnabled;
+//END:RTC_ENABLE_BFRAME
+
 @end
diff --git a/sdk/objc/components/video_codec/RTCDefaultVideoDecoderFactory.m b/sdk/objc/components/video_codec/RTCDefaultVideoDecoderFactory.m
index b45478d..f740058 100644
--- a/sdk/objc/components/video_codec/RTCDefaultVideoDecoderFactory.m
+++ b/sdk/objc/components/video_codec/RTCDefaultVideoDecoderFactory.m
@@ -42,6 +42,7 @@
     @"level-asymmetry-allowed" : @"1",
     @"packetization-mode" : @"1",
   };
+
   RTC_OBJC_TYPE(RTCVideoCodecInfo) *constrainedBaselineInfo =
       [[RTC_OBJC_TYPE(RTCVideoCodecInfo) alloc] initWithName:kRTCVideoCodecH264Name
                                                   parameters:constrainedBaselineParams];
diff --git a/sdk/objc/components/video_codec/RTCDefaultVideoEncoderFactory.h b/sdk/objc/components/video_codec/RTCDefaultVideoEncoderFactory.h
index 92ab40c..45bfcae 100644
--- a/sdk/objc/components/video_codec/RTCDefaultVideoEncoderFactory.h
+++ b/sdk/objc/components/video_codec/RTCDefaultVideoEncoderFactory.h
@@ -24,8 +24,17 @@ RTC_OBJC_EXPORT
 
 @property(nonatomic, retain) RTC_OBJC_TYPE(RTCVideoCodecInfo) *preferredCodec;
 
+#ifdef RTC_ENABLE_BFRAME
+// Since iOS does not support setting the bframe count, only the enableBframe parameter is provided at this time
+- (instancetype)initWithBframe:(BOOL)enableBframe;
++ (NSArray<RTC_OBJC_TYPE(RTCVideoCodecInfo) *> *)supportedCodecsWithBframe:(BOOL)enableBframe;
+#endif // RTC_ENABLE_BFRAME
 + (NSArray<RTC_OBJC_TYPE(RTCVideoCodecInfo) *> *)supportedCodecs;
 
+//START:RTC_ENABLE_BFRAME
+@property(nonatomic, assign) BOOL bframeEnabled;
+//END:RTC_ENABLE_BFRAME
+
 @end
 
 NS_ASSUME_NONNULL_END
diff --git a/sdk/objc/components/video_codec/RTCDefaultVideoEncoderFactory.m b/sdk/objc/components/video_codec/RTCDefaultVideoEncoderFactory.m
index 5d018c8..e1164b7 100644
--- a/sdk/objc/components/video_codec/RTCDefaultVideoEncoderFactory.m
+++ b/sdk/objc/components/video_codec/RTCDefaultVideoEncoderFactory.m
@@ -27,31 +27,73 @@
 
 @implementation RTC_OBJC_TYPE (RTCDefaultVideoEncoderFactory)
 
+//START:RTC_ENABLE_BFRAME
+@synthesize bframeEnabled;
+//END:RTC_ENABLE_BFRAME
+
+#ifdef RTC_ENABLE_BFRAME
+- (instancetype)initWithBframe:(BOOL)enableBframe {
+  if (self = [super init]) {
+    self.bframeEnabled = enableBframe;
+  }
+  return self;
+}
+#endif // RTC_ENABLE_BFRAME
+
 @synthesize preferredCodec;
 
+#ifdef RTC_ENABLE_BFRAME
++ (NSArray<RTC_OBJC_TYPE(RTCVideoCodecInfo) *> *)supportedCodecsWithBframe:(BOOL)enableBframe {
+
+  BOOL enableH264Bframe = enableBframe && [RTCVideoEncoderH264 isBframeSupported];
+# ifdef RTC_ENABLE_H265
+  BOOL enableH265Bframe = enableBframe && [RTCVideoEncoderH265 isBframeSupported];
+# endif // RTC_ENABLE_H265
+#else // RTC_ENABLE_BFRAME
 + (NSArray<RTC_OBJC_TYPE(RTCVideoCodecInfo) *> *)supportedCodecs {
+#endif // RTC_ENABLE_BFRAME
   NSDictionary<NSString *, NSString *> *constrainedHighParams = @{
     @"profile-level-id" : kRTCMaxSupportedH264ProfileLevelConstrainedHigh,
     @"level-asymmetry-allowed" : @"1",
     @"packetization-mode" : @"1",
   };
+#ifdef RTC_ENABLE_BFRAME
+  RTC_OBJC_TYPE(RTCVideoCodecInfo) *constrainedHighInfo = 
+      [[RTC_OBJC_TYPE(RTCVideoCodecInfo) alloc] initWithName:kRTCVideoCodecH264Name
+                                                    parameters:constrainedHighParams
+                                                  enableBframe:enableH264Bframe];
+#else // RTC_ENABLE_BFRAME
   RTC_OBJC_TYPE(RTCVideoCodecInfo) *constrainedHighInfo =
       [[RTC_OBJC_TYPE(RTCVideoCodecInfo) alloc] initWithName:kRTCVideoCodecH264Name
                                                   parameters:constrainedHighParams];
+#endif // RTC_ENABLE_BFRAME
 
   NSDictionary<NSString *, NSString *> *constrainedBaselineParams = @{
     @"profile-level-id" : kRTCMaxSupportedH264ProfileLevelConstrainedBaseline,
     @"level-asymmetry-allowed" : @"1",
     @"packetization-mode" : @"1",
   };
+#ifdef RTC_ENABLE_BFRAME
+  RTC_OBJC_TYPE(RTCVideoCodecInfo) *constrainedBaselineInfo =
+      [[RTC_OBJC_TYPE(RTCVideoCodecInfo) alloc] initWithName:kRTCVideoCodecH264Name
+                                                   parameters:constrainedBaselineParams
+                                                 enableBframe:enableH264Bframe];
+#else // RTC_ENABLE_BFRAME
   RTC_OBJC_TYPE(RTCVideoCodecInfo) *constrainedBaselineInfo =
       [[RTC_OBJC_TYPE(RTCVideoCodecInfo) alloc] initWithName:kRTCVideoCodecH264Name
                                                   parameters:constrainedBaselineParams];
+#endif // RTC_ENABLE_BFRAME
 
 #if defined(RTC_ENABLE_H265)
+# ifdef RTC_ENABLE_BFRAME
+    RTC_OBJC_TYPE(RTCVideoCodecInfo) *h265Info =
+      [[RTC_OBJC_TYPE(RTCVideoCodecInfo) alloc] initWithName:kRTCVideoCodecH265Name
+                                                enableBframe:enableH265Bframe];
+# else // RTC_ENABLE_BFRAME
   RTC_OBJC_TYPE(RTCVideoCodecInfo) *h265Info =
       [[RTC_OBJC_TYPE(RTCVideoCodecInfo) alloc] initWithName:kRTCVideoCodecH265Name];
-#endif
+#	endif // RTC_ENABLE_H265
+#endif // RTC_ENABLE_BFRAME
 
   RTC_OBJC_TYPE(RTCVideoCodecInfo) *vp8Info =
       [[RTC_OBJC_TYPE(RTCVideoCodecInfo) alloc] initWithName:kRTCVideoCodecVp8Name];
@@ -77,9 +119,19 @@
   return result;
 }
 
+#ifdef RTC_ENABLE_BFRAME
++ (NSArray<RTC_OBJC_TYPE(RTCVideoCodecInfo) *> *)supportedCodecs {
+  return [self supportedCodecsWithBframe:NO];
+}
+#endif // RTC_ENABLE_BFRAME
+
 - (id<RTC_OBJC_TYPE(RTCVideoEncoder)>)createEncoder:(RTC_OBJC_TYPE(RTCVideoCodecInfo) *)info {
   if ([info.name isEqualToString:kRTCVideoCodecH264Name]) {
+#ifdef RTC_ENABLE_BFRAME
+    return [[RTC_OBJC_TYPE(RTCVideoEncoderH264) alloc] initWithCodecInfo:info withUserSetBframeEnabled:self.bframeEnabled];
+#else // RTC_ENABLE_BFRAME
     return [[RTC_OBJC_TYPE(RTCVideoEncoderH264) alloc] initWithCodecInfo:info];
+#endif // RTC_ENABLE_BFRAME
   } else if ([info.name isEqualToString:kRTCVideoCodecVp8Name]) {
     return [RTC_OBJC_TYPE(RTCVideoEncoderVP8) vp8Encoder];
   } else if ([info.name isEqualToString:kRTCVideoCodecVp9Name] &&
@@ -88,7 +140,11 @@
 #if defined(RTC_ENABLE_H265)
   } else if (@available(iOS 11, *)) {
     if ([info.name isEqualToString:kRTCVideoCodecH265Name]) {
+# ifdef RTC_ENABLE_BFRAME
+      return [[RTC_OBJC_TYPE(RTCVideoEncoderH265) alloc] initWithCodecInfo:info withUserSetBframeEnabled:self.bframeEnabled];
+# else // RTC_ENABLE_BFRAME
       return [[RTC_OBJC_TYPE(RTCVideoEncoderH265) alloc] initWithCodecInfo:info];
+# endif // RTC_ENABLE_BFRAME
     }
 #endif
   }
@@ -104,7 +160,11 @@
 
 - (NSArray<RTC_OBJC_TYPE(RTCVideoCodecInfo) *> *)supportedCodecs {
   NSMutableArray<RTC_OBJC_TYPE(RTCVideoCodecInfo) *> *codecs =
+#ifdef RTC_ENABLE_BFRAME
+      [[[self class] supportedCodecsWithBframe:self.bframeEnabled] mutableCopy];
+#else // RTC_ENABLE_BFRAME
       [[[self class] supportedCodecs] mutableCopy];
+#endif // RTC_ENABLE_BFRAME
 
   NSMutableArray<RTC_OBJC_TYPE(RTCVideoCodecInfo) *> *orderedCodecs = [NSMutableArray array];
   NSUInteger index = [codecs indexOfObject:self.preferredCodec];
diff --git a/sdk/objc/components/video_codec/RTCVideoDecoderH264.h b/sdk/objc/components/video_codec/RTCVideoDecoderH264.h
index a12e421..1331545 100644
--- a/sdk/objc/components/video_codec/RTCVideoDecoderH264.h
+++ b/sdk/objc/components/video_codec/RTCVideoDecoderH264.h
@@ -15,4 +15,5 @@
 
 RTC_OBJC_EXPORT
 @interface RTC_OBJC_TYPE (RTCVideoDecoderH264) : NSObject <RTC_OBJC_TYPE(RTCVideoDecoder)>
+
 @end
diff --git a/sdk/objc/components/video_codec/RTCVideoDecoderH264.mm b/sdk/objc/components/video_codec/RTCVideoDecoderH264.mm
index 6708b26..8b9da00 100644
--- a/sdk/objc/components/video_codec/RTCVideoDecoderH264.mm
+++ b/sdk/objc/components/video_codec/RTCVideoDecoderH264.mm
@@ -29,18 +29,45 @@
 #include "rtc_base/time_utils.h"
 #include "sdk/objc/components/video_codec/nalu_rewriter.h"
 
+#ifdef RTC_ENABLE_BFRAME
+# import <deque>
+# import "ts_rollover_helper.h"
+# import "common_video/h264/h264_bitstream_parser.h"
+
+# define RTC_ENABLE_BFRAME_TRACE
+# define MAX_BFRAME_REORDER_QUEUE_COUNT 10
+#endif // RTC_ENABLE_BFRAME
+
 // Struct that we pass to the decoder per frame to decode. We receive it again
 // in the decoder callback.
 struct RTCFrameDecodeParams {
   RTCFrameDecodeParams(RTCVideoDecoderCallback cb, int64_t ts) : callback(cb), timestamp(ts) {}
   RTCVideoDecoderCallback callback;
   int64_t timestamp;
+#ifdef RTC_ENABLE_BFRAME
+  // Decode TimeStamp (timebase: 90KHz)
+  uint32_t dts;
+  uint8_t sliceType;
+#endif // RTC_ENABLE_BFRAME
 };
 
 @interface RTC_OBJC_TYPE (RTCVideoDecoderH264)
 () - (void)setError : (OSStatus)error;
+
+#ifdef RTC_ENABLE_BFRAME
+- (void)processBframe:(RTC_OBJC_TYPE(RTCVideoFrame) *)decodedFrame
+         decodeParams:(RTCFrameDecodeParams *)decodeParams;
+#endif // RTC_ENABLE_BFRAME
 @end
 
+#ifdef RTC_ENABLE_BFRAME_TRACE
+static const char *GetSliceTypeString(uint8_t sliceType) {
+  static const char *SLICE_TYPES[] = { "P", "B", "I", "SP", "SI", "P", "B", "I", "SP", "SI" };
+  
+  return ((sliceType < (sizeof(SLICE_TYPES) / sizeof(SLICE_TYPES[0]))) ? SLICE_TYPES[sliceType] : "N/A");
+}
+#endif // RTC_ENABLE_BFRAME_TRACE
+
 // This is the callback function that VideoToolbox calls when decode is
 // complete.
 void decompressionOutputCallback(void *decoderRef,
@@ -59,6 +86,7 @@ void decompressionOutputCallback(void *decoderRef,
     RTC_LOG(LS_ERROR) << "Failed to decode frame. Status: " << status;
     return;
   }
+
   // TODO(tkchin): Handle CVO properly.
   RTC_OBJC_TYPE(RTCCVPixelBuffer) *frameBuffer =
       [[RTC_OBJC_TYPE(RTCCVPixelBuffer) alloc] initWithPixelBuffer:imageBuffer];
@@ -66,8 +94,17 @@ void decompressionOutputCallback(void *decoderRef,
       initWithBuffer:frameBuffer
             rotation:RTCVideoRotation_0
          timeStampNs:CMTimeGetSeconds(timestamp) * rtc::kNumNanosecsPerSec];
+
   decodedFrame.timeStamp = decodeParams->timestamp;
+#ifdef RTC_ENABLE_BFRAME
+  RTC_OBJC_TYPE(RTCVideoDecoderH264) *decoder =
+      (__bridge RTC_OBJC_TYPE(RTCVideoDecoderH264) *)decoderRef;
+  
+  [decoder processBframe:decodedFrame
+            decodeParams:decodeParams.get()];
+#else // RTC_ENABLE_BFRAME
   decodeParams->callback(decodedFrame);
+#endif // RTC_ENABLE_BFRAME
 }
 
 // Decoder.
@@ -77,16 +114,97 @@ void decompressionOutputCallback(void *decoderRef,
   VTDecompressionSessionRef _decompressionSession;
   RTCVideoDecoderCallback _callback;
   OSStatus _error;
+
+#ifdef RTC_ENABLE_BFRAME
+  BOOL _isVuiParsed;
+  BOOL _needToReorder;
+  
+  // Used to sort frames decoded by PTS
+  // Key: PTS, Value: instance of RTCVideoFrame
+  std::map<int64_t, RTC_OBJC_TYPE(RTCVideoFrame) *> _reorderMap;
+  std::mutex _reorderMapMutex;
+
+  TsRolloverHelper _rolloverHelper;
+#endif // RTC_ENABLE_BFRAME
 }
 
 - (instancetype)init {
   self = [super init];
   if (self) {
     _memoryPool = CMMemoryPoolCreate(nil);
+
+#ifdef RTC_ENABLE_BFRAME
+    _isVuiParsed = NO;
+    _needToReorder = YES;
+#endif // RTC_ENABLE_BFRAME
   }
   return self;
 }
 
+#ifdef RTC_ENABLE_BFRAME
+- (void)processBframe:(RTC_OBJC_TYPE(RTCVideoFrame) *)decodedFrame
+         decodeParams:(RTCFrameDecodeParams *)decodeParams {
+  if (_isVuiParsed && (_needToReorder == NO)) {
+    decodeParams->callback(decodedFrame);
+    return;
+  }
+
+  const BOOL isIorPFrame = ((decodeParams->sliceType == webrtc::H264::SliceType::kI) ||
+                            (decodeParams->sliceType == webrtc::H264::SliceType::kP) ||
+                            (decodeParams->sliceType == webrtc::H264::SliceType::kSp));
+
+  bool isRolled;
+  const uint32_t lastPts = _rolloverHelper.UpdateTs(decodeParams->timestamp, &isRolled);
+  const int64_t accumulatedPts = _rolloverHelper.CurrentTs();
+  
+  if (isRolled) {
+    RTC_LOG(LS_VERBOSE)
+    << "[H264Decoder] PTS is rolled: "
+    << lastPts << " to " << decodeParams->timestamp
+    << ", accumulated: " << accumulatedPts;
+  }
+  
+# ifdef RTC_ENABLE_BFRAME_TRACE
+  {
+    RTC_LOG(LS_VERBOSE)
+    << "[H264Decoder] Frame is decoded: "
+    << "DTS: " << decodeParams->dts
+    << ", PTS: " << decodeParams->timestamp << " (accumulated: " << accumulatedPts << ")"
+    << ", " << GetSliceTypeString(decodeParams->sliceType) << " (" << decodeParams->sliceType << ")";
+  }
+# endif
+  
+  // Flush the reorder queue if the decoded frame is I or P frame
+  if (isIorPFrame) {
+    std::map<int64_t, RTC_OBJC_TYPE(RTCVideoFrame) *> reorderMap;
+    
+    {
+      std::lock_guard lockGuard(_reorderMapMutex);
+      reorderMap = std::move(_reorderMap);
+    }
+    
+    for (auto &frameIterator : reorderMap) {
+# ifdef RTC_ENABLE_BFRAME_TRACE
+      RTC_LOG(LS_VERBOSE)
+      << "[H264Decoder] Callbacking the frame: "
+      << "PTS: " << static_cast<uint32_t>(frameIterator.second.timeStamp)
+      << " (accumulated: " << frameIterator.first << ")";
+# endif // RTC_ENABLE_BFRAME_TRACE
+      decodeParams->callback(frameIterator.second);
+    }
+  }
+  
+  {
+    std::lock_guard lockGuard(_reorderMapMutex);
+    _reorderMap[accumulatedPts] = decodedFrame;
+    if (_reorderMap.size() > MAX_BFRAME_REORDER_QUEUE_COUNT) {
+      RTC_LOG(LS_ERROR) << "[H264Decoder] Reorder queue is full. Dropping the first frame in the queue....";
+      _reorderMap.erase(_reorderMap.begin());
+    }
+  }
+}
+#endif // RTC_ENABLE_BFRAME
+
 - (void)dealloc {
   CMMemoryPoolInvalidate(_memoryPool);
   CFRelease(_memoryPool);
@@ -110,6 +228,26 @@ void decompressionOutputCallback(void *decoderRef,
     _error = noErr;
     return WEBRTC_VIDEO_CODEC_ERROR;
   }
+#ifdef RTC_ENABLE_BFRAME
+  if ((_isVuiParsed == NO) && (inputImage.frameType == RTCFrameType::RTCFrameTypeVideoFrameKey)) {
+    RTC_LOG(LS_VERBOSE) << "Trying to parse max_num_reorder_frames...";
+
+    webrtc::H264BitstreamParser h264BitstreamParser;
+    rtc::ArrayView<const uint8_t> inputBuffer((const uint8_t *)inputImage.buffer.bytes, inputImage.buffer.length);
+    h264BitstreamParser.ParseBitstream(inputBuffer);
+
+    absl::optional<int32_t> maxReorderFrames = h264BitstreamParser.GetMaxNumReorderFrames();
+
+    if (maxReorderFrames.has_value()) {
+      RTC_LOG(LS_VERBOSE) << "Stream has max_num_reorder_frames_: " << maxReorderFrames.value();
+      _needToReorder = (maxReorderFrames.value() > 0);
+    } else {
+      RTC_LOG(LS_VERBOSE) << "There is no max_num_reorder_frames in the stream.";
+    }
+
+    _isVuiParsed = YES;
+  }
+#endif // RTC_ENABLE_BFRAME
 
   rtc::ScopedCFTypeRef<CMVideoFormatDescriptionRef> inputFormat =
       rtc::ScopedCF(webrtc::CreateVideoFormatDescription((uint8_t *)inputImage.buffer.bytes,
@@ -146,6 +284,30 @@ void decompressionOutputCallback(void *decoderRef,
   VTDecodeFrameFlags decodeFlags = kVTDecodeFrame_EnableAsynchronousDecompression;
   std::unique_ptr<RTCFrameDecodeParams> frameDecodeParams;
   frameDecodeParams.reset(new RTCFrameDecodeParams(_callback, inputImage.timeStamp));
+#ifdef RTC_ENABLE_BFRAME
+  uint32_t dts = inputImage.dts.unsignedIntValue;
+  frameDecodeParams->dts = dts;
+  uint8_t sliceType = (inputImage.frameType == RTCFrameType::RTCFrameTypeVideoFrameKey)
+  ? webrtc::H264::SliceType::kI
+  : (
+     (inputImage.frameType == RTCFrameType::RTCFrameTypeVideoFrameDelta)
+     ? (inputImage.isBframe.boolValue ? webrtc::H264::SliceType::kB : webrtc::H264::SliceType::kP)
+     : 0xff
+     );
+  frameDecodeParams->sliceType = sliceType;
+  
+# ifdef RTC_ENABLE_BFRAME_TRACE
+  if (_needToReorder) {
+    RTC_LOG(LS_VERBOSE)
+    << "[H264Decoder] Trying to decode data " << inputImage.buffer.length << " bytes"
+    << ", timeStamp: " << inputImage.timeStamp
+    << ", DTS: " << frameDecodeParams->dts
+    << ", frameType: " << inputImage.frameType
+    << ", isBframe: " << inputImage.isBframe.boolValue
+    << ", " << GetSliceTypeString(sliceType) << " (" << sliceType << ")";
+  }
+# endif // RTC_ENABLE_BFRAME_TRACE
+#endif // RTC_ENABLE_BFRAME
   OSStatus status = VTDecompressionSessionDecodeFrame(
       _decompressionSession, sampleBuffer, decodeFlags, frameDecodeParams.release(), nullptr);
 #if defined(WEBRTC_IOS)
@@ -156,6 +318,10 @@ void decompressionOutputCallback(void *decoderRef,
     RTC_LOG(LS_INFO) << "Failed to decode frame with code: " << status
                      << " retrying decode after decompression session reset";
     frameDecodeParams.reset(new RTCFrameDecodeParams(_callback, inputImage.timeStamp));
+# ifdef RTC_ENABLE_BFRAME
+    frameDecodeParams->dts = dts;
+    frameDecodeParams->sliceType = sliceType;
+# endif // RTC_ENABLE_BFRAME
     status = VTDecompressionSessionDecodeFrame(
         _decompressionSession, sampleBuffer, decodeFlags, frameDecodeParams.release(), nullptr);
   }
@@ -177,6 +343,12 @@ void decompressionOutputCallback(void *decoderRef,
 }
 
 - (NSInteger)releaseDecoder {
+#ifdef RTC_ENABLE_BFRAME
+  {
+    std::lock_guard lockGuard(_reorderMapMutex);
+    _reorderMap.clear();
+  }
+#endif // RTC_ENABLE_BFRAME
   // Need to invalidate the session so that callbacks no longer occur and it
   // is safe to null out the callback.
   [self destroyDecompressionSession];
@@ -253,6 +425,9 @@ void decompressionOutputCallback(void *decoderRef,
     CFRelease(_decompressionSession);
     _decompressionSession = nullptr;
   }
+#ifdef RTC_ENABLE_BFRAME
+  _rolloverHelper.Reset();
+#endif // RTC_ENABLE_BFRAME
 }
 
 - (void)setVideoFormat:(CMVideoFormatDescriptionRef)videoFormat {
diff --git a/sdk/objc/components/video_codec/RTCVideoDecoderH265.h b/sdk/objc/components/video_codec/RTCVideoDecoderH265.h
index 318bb4a..e5fbfe9 100644
--- a/sdk/objc/components/video_codec/RTCVideoDecoderH265.h
+++ b/sdk/objc/components/video_codec/RTCVideoDecoderH265.h
@@ -16,8 +16,12 @@
 RTC_OBJC_EXPORT
 @interface RTC_OBJC_TYPE (RTCVideoDecoderH265) : NSObject <RTC_OBJC_TYPE(RTCVideoDecoder)>
 - (NSInteger)setAVCFormat:(const uint8_t *)data size:(size_t)size width:(uint16_t)width height:(uint16_t)height;
+#ifdef RTC_ENABLE_BFRAME
+- (NSInteger)decodeData:(RTC_OBJC_TYPE(RTCEncodedImage)*)inputImage;
+#else // RTC_ENABLE_BFRAME
 - (NSInteger)decodeData:(const uint8_t *)data
     size:(size_t)size
     timeStamp:(int64_t)timeStamp;
+#endif // RTC_ENABLE_BFRAME
 - (void)flush;
 @end
diff --git a/sdk/objc/components/video_codec/RTCVideoDecoderH265.mm b/sdk/objc/components/video_codec/RTCVideoDecoderH265.mm
index 1a6a6cf..be6be59 100644
--- a/sdk/objc/components/video_codec/RTCVideoDecoderH265.mm
+++ b/sdk/objc/components/video_codec/RTCVideoDecoderH265.mm
@@ -25,6 +25,14 @@
 #include "rtc_base/time_utils.h"
 #include "sdk/objc/components/video_codec/nalu_rewriter.h"
 
+#ifdef RTC_ENABLE_BFRAME
+# import <deque>
+# import "ts_rollover_helper.h"
+
+# define RTC_ENABLE_BFRAME_TRACE
+# define MAX_BFRAME_REORDER_QUEUE_COUNT 10
+#endif // RTC_ENABLE_BFRAME
+
 // Struct that we pass to the decoder per frame to decode. We receive it again
 // in the decoder callback.
 struct RTCH265FrameDecodeParams {
@@ -32,10 +40,28 @@ struct RTCH265FrameDecodeParams {
       : callback(cb), timestamp(ts) {}
   RTCVideoDecoderCallback callback;
   int64_t timestamp;
+#ifdef RTC_ENABLE_BFRAME
+  // Decode TimeStamp (timebase: 90KHz)
+  uint32_t dts;
+  uint8_t sliceType;
+#endif // RTC_ENABLE_BFRAME
 };
 
+# ifdef RTC_ENABLE_BFRAME_TRACE
+static const char *GetSliceTypeString(uint8_t sliceType) {
+  static const char *SLICE_TYPES[] = { "B", "P", "I" };
+  
+  return ((sliceType < (sizeof(SLICE_TYPES) / sizeof(SLICE_TYPES[0]))) ? SLICE_TYPES[sliceType] : "N/A");
+}
+# endif // RTC_ENABLE_BFRAME_TRACE
+
 @interface RTC_OBJC_TYPE (RTCVideoDecoderH265) ()
 - (void)setError:(OSStatus)error;
+
+#ifdef RTC_ENABLE_BFRAME
+- (void)processBframe:(RTC_OBJC_TYPE(RTCVideoFrame) *)decodedFrame
+         decodeParams:(RTCH265FrameDecodeParams *)decodeParams;
+#endif // RTC_ENABLE_BFRAME
 @end
 
 static void overrideColorSpaceAttachments(CVImageBufferRef imageBuffer) {
@@ -73,8 +99,17 @@ void h265DecompressionOutputCallback(void* decoderRef,
       initWithBuffer:frameBuffer
             rotation:RTCVideoRotation_0
          timeStampNs:CMTimeGetSeconds(timestamp) * rtc::kNumNanosecsPerSec];
+
   decodedFrame.timeStamp = decodeParams->timestamp;
+#ifdef RTC_ENABLE_BFRAME
+  RTC_OBJC_TYPE(RTCVideoDecoderH265) *decoder =
+      (__bridge RTC_OBJC_TYPE(RTCVideoDecoderH265) *)decoderRef;
+  
+  [decoder processBframe:decodedFrame
+            decodeParams:decodeParams.get()];
+#else // RTC_ENABLE_BFRAME
   decodeParams->callback(decodedFrame);
+#endif // RTC_ENABLE_BFRAME
 }
 
 // Decoder.
@@ -84,16 +119,83 @@ void h265DecompressionOutputCallback(void* decoderRef,
   RTCVideoDecoderCallback _callback;
   OSStatus _error;
   bool _useAVC;
+  
+#ifdef RTC_ENABLE_BFRAME
+  // Used to sort frames decoded by PTS
+  // Key: PTS, Value: instance of RTCVideoFrame
+  std::map<int64_t, RTC_OBJC_TYPE(RTCVideoFrame) *> _reorderMap;
+  std::mutex _reorderMapMutex;
+
+  TsRolloverHelper _rolloverHelper;
+#endif // RTC_ENABLE_BFRAME
 }
 
 - (instancetype)init {
   if (self = [super init]) {
     _useAVC = false;
   }
-
+  
   return self;
 }
 
+#ifdef RTC_ENABLE_BFRAME
+- (void)processBframe:(RTC_OBJC_TYPE(RTCVideoFrame) *)decodedFrame
+         decodeParams:(RTCH265FrameDecodeParams *)decodeParams {
+  const BOOL isIorPFrame = ((decodeParams->sliceType == webrtc::H265::SliceType::kI) ||
+                           (decodeParams->sliceType == webrtc::H265::SliceType::kP));
+  
+  bool isRolled;
+  const uint32_t lastPts = _rolloverHelper.UpdateTs(decodeParams->timestamp, &isRolled);
+  const int64_t accumulatedPts = _rolloverHelper.CurrentTs();
+  
+  if (isRolled) {
+    RTC_LOG(LS_VERBOSE)
+    << "[H265Decoder] PTS is rolled: "
+    << lastPts << " to " << decodeParams->timestamp
+    << ", accumulated: " << accumulatedPts;
+  }
+  
+# ifdef RTC_ENABLE_BFRAME_TRACE
+  {
+    RTC_LOG(LS_VERBOSE)
+    << "[H265Decoder] Frame is decoded: "
+    << "DTS: " << decodeParams->dts
+    << ", PTS: " << decodeParams->timestamp << " (accumulated: " << accumulatedPts << ")"
+    << ", " << GetSliceTypeString(decodeParams->sliceType) << " (" << decodeParams->sliceType << ")";
+  }
+# endif
+  
+  // Flush the reorder queue if the decoded frame is I or P frame
+  if (isIorPFrame) {
+    std::map<int64_t, RTC_OBJC_TYPE(RTCVideoFrame) *> reorderMap;
+    
+    {
+      std::lock_guard lockGuard(_reorderMapMutex);
+      reorderMap = std::move(_reorderMap);
+    }
+
+    for (auto &frameIterator : reorderMap) {
+# ifdef RTC_ENABLE_BFRAME_TRACE
+      RTC_LOG(LS_VERBOSE)
+      << "[H265Decoder] Callbacking the frame: "
+      << "PTS: " << frameIterator.second.timeStamp
+      << " (accumulated: " << frameIterator.first << ")";
+# endif // RTC_ENABLE_BFRAME_TRACE
+      decodeParams->callback(frameIterator.second);
+    }
+  }
+  
+  {
+    std::lock_guard lockGuard(_reorderMapMutex);
+    _reorderMap[accumulatedPts] = decodedFrame;
+    if (_reorderMap.size() > MAX_BFRAME_REORDER_QUEUE_COUNT) {
+      RTC_LOG(LS_ERROR) << "[H265Decoder] Reorder queue is full. Dropping the first frame in the queue....";
+      _reorderMap.erase(_reorderMap.begin());
+    }
+  }
+}
+#endif // RTC_ENABLE_BFRAME
+
 - (void)dealloc {
   [self destroyDecompressionSession];
   [self setVideoFormat:nullptr];
@@ -110,12 +212,12 @@ CMSampleBufferRef H265BufferToCMSampleBuffer(const uint8_t* buffer, size_t buffe
     return nullptr;
   }
   auto block_buffer = rtc::ScopedCF(new_block_buffer);
-
+  
   if (auto error = CMBlockBufferReplaceDataBytes(buffer, block_buffer.get(), 0, buffer_size)) {
     RTC_LOG(LS_ERROR) << "H265BufferToCMSampleBuffer CMBlockBufferReplaceDataBytes failed with: " << error;
     return nullptr;
   }
-
+  
   CMSampleBufferRef sample_buffer = nullptr;
   if (auto error = CMSampleBufferCreate(kCFAllocatorDefault, block_buffer.get(), true, nullptr, nullptr, video_format, 1, 0, nullptr, 0, nullptr, &sample_buffer)) {
     RTC_LOG(LS_ERROR) << "H265BufferToCMSampleBuffer CMSampleBufferCreate failed with: " << error;
@@ -129,10 +231,22 @@ CMSampleBufferRef H265BufferToCMSampleBuffer(const uint8_t* buffer, size_t buffe
       codecSpecificInfo:(__nullable id<RTC_OBJC_TYPE(RTCCodecSpecificInfo)>)info
            renderTimeMs:(int64_t)renderTimeMs {
   RTC_DCHECK(inputImage.buffer);
+#ifdef RTC_ENABLE_BFRAME
+  return [self decodeData:inputImage];
+#else // RTC_ENABLE_BFRAME
   return [self decodeData: (uint8_t *)inputImage.buffer.bytes size: inputImage.buffer.length timeStamp: inputImage.timeStamp];
+#endif // RTC_ENABLE_BFRAME
 }
 
+#ifdef RTC_ENABLE_BFRAME
+- (NSInteger)decodeData:(RTC_OBJC_TYPE(RTCEncodedImage)*)inputImage {
+  const uint8_t *data = reinterpret_cast<const uint8_t *>(inputImage.buffer.bytes);
+  const size_t size = inputImage.buffer.length;
+  const int64_t timeStamp = inputImage.timeStamp;
+  
+#else // RTC_ENABLE_BFRAME
 - (NSInteger)decodeData:(const uint8_t *)data size:(size_t)size timeStamp:(int64_t)timeStamp {
+#endif // RTC_ENABLE_BFRAME
   if (_error != noErr) {
     RTC_LOG(LS_WARNING) << "Last frame decode failed.";
     _error = noErr;
@@ -177,7 +291,11 @@ CMSampleBufferRef H265BufferToCMSampleBuffer(const uint8_t* buffer, size_t buffe
     if (!sampleBuffer)
       return WEBRTC_VIDEO_CODEC_ERROR;
   } else if (!webrtc::H265AnnexBBufferToCMSampleBuffer(
+#ifdef RTC_ENABLE_BFRAME
+          data, size,
+#else
           (uint8_t*)data, size,
+#endif // RTC_ENABLE_BFRAME
           _videoFormat, &sampleBuffer)) {
     return WEBRTC_VIDEO_CODEC_ERROR;
   }
@@ -187,6 +305,30 @@ CMSampleBufferRef H265BufferToCMSampleBuffer(const uint8_t* buffer, size_t buffe
   std::unique_ptr<RTCH265FrameDecodeParams> frameDecodeParams;
   frameDecodeParams.reset(
       new RTCH265FrameDecodeParams(_callback, timeStamp));
+
+#ifdef RTC_ENABLE_BFRAME
+  uint32_t dts = inputImage.dts.unsignedIntValue;
+  frameDecodeParams->dts = dts;
+  uint8_t sliceType = (inputImage.frameType == RTCFrameType::RTCFrameTypeVideoFrameKey)
+  ? webrtc::H265::SliceType::kI
+  : (
+     (inputImage.frameType == RTCFrameType::RTCFrameTypeVideoFrameDelta)
+     ? (inputImage.isBframe.boolValue ? webrtc::H265::SliceType::kB : webrtc::H265::SliceType::kP)
+     : 0xff
+     );
+  frameDecodeParams->sliceType = sliceType;
+  
+# ifdef RTC_ENABLE_BFRAME_TRACE
+  RTC_LOG(LS_VERBOSE)
+  << "[H265Decoder] Trying to decode data " << size << " bytes"
+  << ", timeStamp: " << timeStamp
+  << ", DTS: " << frameDecodeParams->dts
+  << ", frameType: " << inputImage.frameType
+  << ", isBframe: " << inputImage.isBframe.boolValue
+  << ", " << GetSliceTypeString(sliceType) << " (" << sliceType << ")";
+# endif // RTC_ENABLE_BFRAME_TRACE
+#endif //RTC_ENABLE_BFRAME
+
   OSStatus status = VTDecompressionSessionDecodeFrame(
       _decompressionSession, sampleBuffer, decodeFlags,
       frameDecodeParams.release(), nullptr);
@@ -197,6 +339,10 @@ CMSampleBufferRef H265BufferToCMSampleBuffer(const uint8_t* buffer, size_t buffe
       [self resetDecompressionSession] == WEBRTC_VIDEO_CODEC_OK) {
     frameDecodeParams.reset(
         new RTCH265FrameDecodeParams(_callback, timeStamp));
+# ifdef RTC_ENABLE_BFRAME
+    frameDecodeParams->dts = dts;
+    frameDecodeParams->sliceType = sliceType;
+# endif // RTC_ENABLE_BFRAME
     status = VTDecompressionSessionDecodeFrame(
         _decompressionSession, sampleBuffer, decodeFlags,
         frameDecodeParams.release(), nullptr);
@@ -262,6 +408,12 @@ CMSampleBufferRef H265BufferToCMSampleBuffer(const uint8_t* buffer, size_t buffe
 }
 
 - (NSInteger)releaseDecoder {
+#ifdef RTC_ENABLE_BFRAME
+  {
+    std::lock_guard lockGuard(_reorderMapMutex);
+    _reorderMap.clear();
+  }
+#endif // RTC_ENABLE_BFRAME
   // Need to invalidate the session so that callbacks no longer occur and it
   // is safe to null out the callback.
   [self destroyDecompressionSession];
@@ -316,7 +468,11 @@ CMSampleBufferRef H265BufferToCMSampleBuffer(const uint8_t* buffer, size_t buffe
   }
   VTDecompressionOutputCallbackRecord record = {
       h265DecompressionOutputCallback,
-      nullptr,
+#ifdef RTC_ENABLE_BFRAME
+      (__bridge void *)self,
+#else // RTC_ENABLE_BFRAME
+      nullptr
+#endif // RTC_ENABLE_BFRAME
   };
   OSStatus status =
       VTDecompressionSessionCreate(nullptr, _videoFormat, nullptr, attributes,
@@ -347,6 +503,9 @@ CMSampleBufferRef H265BufferToCMSampleBuffer(const uint8_t* buffer, size_t buffe
     CFRelease(_decompressionSession);
     _decompressionSession = nullptr;
   }
+#ifdef RTC_ENABLE_BFRAME
+  _rolloverHelper.Reset();
+#endif // RTC_ENABLE_BFRAME
 }
 
 - (void)flush {
diff --git a/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH264.h b/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH264.h
index 45fc4be..7201759 100644
--- a/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH264.h
+++ b/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH264.h
@@ -15,4 +15,14 @@
 
 RTC_OBJC_EXPORT
 @interface RTC_OBJC_TYPE (RTCVideoEncoderFactoryH264) : NSObject <RTC_OBJC_TYPE(RTCVideoEncoderFactory)>
+
+#ifdef RTC_ENABLE_BFRAME
+// Since iOS does not support setting the bframe count, only the enableBframe parameter is provided at this time
+- (instancetype)initWithBframe:(BOOL)enableBframe;
+#endif // RTC_ENABLE_BFRAME
+
+//START:RTC_ENABLE_BFRAME
+@property(nonatomic, assign) BOOL bframeEnabled;
+//END:RTC_ENABLE_BFRAME
+
 @end
diff --git a/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH264.m b/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH264.m
index 9843849..323880e 100644
--- a/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH264.m
+++ b/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH264.m
@@ -15,18 +15,43 @@
 
 @implementation RTC_OBJC_TYPE (RTCVideoEncoderFactoryH264)
 
+//START:RTC_ENABLE_BFRAME
+@synthesize bframeEnabled;
+//END:RTC_ENABLE_BFRAME
+
+#ifdef RTC_ENABLE_BFRAME
+- (instancetype)initWithBframe:(BOOL)enableBframe {
+  if (self = [super init]) {
+    self.bframeEnabled = enableBframe;
+  }
+  return self;
+}
+#endif // RTC_ENABLE_BFRAME
+
 - (NSArray<RTC_OBJC_TYPE(RTCVideoCodecInfo) *> *)supportedCodecs {
   NSMutableArray<RTC_OBJC_TYPE(RTCVideoCodecInfo) *> *codecs = [NSMutableArray array];
   NSString *codecName = kRTCVideoCodecH264Name;
 
+#ifdef RTC_ENABLE_BFRAME
+  BOOL enableH264Bframe = self.bframeEnabled && [RTCVideoEncoderH264 isBframeSupported];
+#endif // RTC_ENABLE_BFRAME
+
   NSDictionary<NSString *, NSString *> *constrainedHighParams = @{
     @"profile-level-id" : kRTCMaxSupportedH264ProfileLevelConstrainedHigh,
     @"level-asymmetry-allowed" : @"1",
     @"packetization-mode" : @"1",
   };
+#ifdef RTC_ENABLE_BFRAME
+  RTC_OBJC_TYPE(RTCVideoCodecInfo) *constrainedHighInfo =
+      [[RTC_OBJC_TYPE(RTCVideoCodecInfo) alloc] initWithName:codecName
+                                                  parameters:constrainedHighParams
+                                                enableBframe:enableH264Bframe];
+#else // RTC_ENABLE_BFRAME
   RTC_OBJC_TYPE(RTCVideoCodecInfo) *constrainedHighInfo =
       [[RTC_OBJC_TYPE(RTCVideoCodecInfo) alloc] initWithName:codecName
                                                   parameters:constrainedHighParams];
+#endif // RTC_ENABLE_BFRAME
+
   [codecs addObject:constrainedHighInfo];
 
   NSDictionary<NSString *, NSString *> *constrainedBaselineParams = @{
@@ -34,16 +59,28 @@
     @"level-asymmetry-allowed" : @"1",
     @"packetization-mode" : @"1",
   };
+#ifdef RTC_ENABLE_BFRAME
+  RTC_OBJC_TYPE(RTCVideoCodecInfo) *constrainedBaselineInfo =
+      [[RTC_OBJC_TYPE(RTCVideoCodecInfo) alloc] initWithName:codecName
+                                                  parameters:constrainedBaselineParams
+                                                enableBframe:enableH264Bframe];
+#else // RTC_ENABLE_BFRAME
   RTC_OBJC_TYPE(RTCVideoCodecInfo) *constrainedBaselineInfo =
       [[RTC_OBJC_TYPE(RTCVideoCodecInfo) alloc] initWithName:codecName
                                                   parameters:constrainedBaselineParams];
+#endif // RTC_ENABLE_BFRAME
+
   [codecs addObject:constrainedBaselineInfo];
 
   return [codecs copy];
 }
 
 - (id<RTC_OBJC_TYPE(RTCVideoEncoder)>)createEncoder:(RTC_OBJC_TYPE(RTCVideoCodecInfo) *)info {
+#ifdef RTC_ENABLE_BFRAME
+  return [[RTC_OBJC_TYPE(RTCVideoEncoderH264) alloc] initWithCodecInfo:info withUserSetBframeEnabled:self.bframeEnabled];
+#else // RTC_ENABLE_BFRAME
   return [[RTC_OBJC_TYPE(RTCVideoEncoderH264) alloc] initWithCodecInfo:info];
+#endif // RTC_ENABLE_BFRAME
 }
 
 @end
diff --git a/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH265.h b/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH265.h
index 165c52d..0551bb7 100644
--- a/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH265.h
+++ b/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH265.h
@@ -15,4 +15,14 @@
 
 RTC_OBJC_EXPORT
 @interface RTC_OBJC_TYPE (RTCVideoEncoderFactoryH265) : NSObject <RTC_OBJC_TYPE(RTCVideoEncoderFactory)>
+
+#ifdef RTC_ENABLE_BFRAME
+// Since iOS does not support setting the bframe count, only the enableBframe parameter is provided at this time
+- (instancetype)initWithBframe:(BOOL)enableBframe;
+#endif // RTC_ENABLE_BFRAME
+
+//START:RTC_ENABLE_BFRAME
+@property(nonatomic, assign) BOOL bframeEnabled;
+//END:RTC_ENABLE_BFRAME
+
 @end
diff --git a/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH265.m b/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH265.m
index f41233d..47123d1 100644
--- a/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH265.m
+++ b/sdk/objc/components/video_codec/RTCVideoEncoderFactoryH265.m
@@ -15,11 +15,34 @@
 
 @implementation RTC_OBJC_TYPE (RTCVideoEncoderFactoryH265)
 
+//START:RTC_ENABLE_BFRAME
+@synthesize bframeEnabled;
+//END:RTC_ENABLE_BFRAME
+
+#ifdef RTC_ENABLE_BFRAME
+- (instancetype)initWithBframe:(BOOL)enableBframe {
+  if (self = [super init]) {
+    self.bframeEnabled = enableBframe;
+  }
+  return self;
+}
+#endif // RTC_ENABLE_BFRAME
+
 - (NSArray<RTC_OBJC_TYPE(RTCVideoCodecInfo) *> *)supportedCodecs {
   NSMutableArray<RTC_OBJC_TYPE(RTCVideoCodecInfo) *> *codecs = [NSMutableArray array];
 
+#ifdef RTC_ENABLE_BFRAME
+  BOOL enableH265Bframe = self.bframeEnabled && [RTCVideoEncoderH265 isBframeSupported];
+#endif // RTC_ENABLE_BFRAME
+
+#ifdef RTC_ENABLE_BFRAME
+  RTC_OBJC_TYPE(RTCVideoCodecInfo) *h265Info =
+      [[RTC_OBJC_TYPE(RTCVideoCodecInfo) alloc] initWithName:kRTCVideoCodecH265Name
+                                                enableBframe:enableH265Bframe];
+#else
   RTC_OBJC_TYPE(RTCVideoCodecInfo) *h265Info =
       [[RTC_OBJC_TYPE(RTCVideoCodecInfo) alloc] initWithName:kRTCVideoCodecH265Name];
+#endif
   [codecs addObject:h265Info];
 
   return [codecs copy];
@@ -27,7 +50,11 @@
 
 - (id<RTC_OBJC_TYPE(RTCVideoEncoder)>)createEncoder:(RTC_OBJC_TYPE(RTCVideoCodecInfo) *)info {
   if (@available(iOS 11, *)) {
+# ifdef RTC_ENABLE_BFRAME
+    return [[RTC_OBJC_TYPE(RTCVideoEncoderH265) alloc] initWithCodecInfo:info withUserSetBframeEnabled:self.bframeEnabled];
+# else // RTC_ENABLE_BFRAME
     return [[RTC_OBJC_TYPE(RTCVideoEncoderH265) alloc] initWithCodecInfo:info];
+# endif // RTC_ENABLE_BFRAME
   }
   return nil;
 }
diff --git a/sdk/objc/components/video_codec/RTCVideoEncoderH264.h b/sdk/objc/components/video_codec/RTCVideoEncoderH264.h
index 9f4f4c7..053f5be 100644
--- a/sdk/objc/components/video_codec/RTCVideoEncoderH264.h
+++ b/sdk/objc/components/video_codec/RTCVideoEncoderH264.h
@@ -19,4 +19,13 @@ RTC_OBJC_EXPORT
 
 - (instancetype)initWithCodecInfo:(RTC_OBJC_TYPE(RTCVideoCodecInfo) *)codecInfo;
 
+#ifdef RTC_ENABLE_BFRAME
+- (instancetype)initWithCodecInfo:(RTC_OBJC_TYPE(RTCVideoCodecInfo) *)codecInfo withUserSetBframeEnabled:(BOOL)bframeEnabled;
++ (BOOL)isBframeSupported;
+#endif // RTC_ENABLE_BFRAME
+
+//START:RTC_ENABLE_BFRAME
+@property (nonatomic, assign) BOOL bframeEnabled;
+//END:RTC_ENABLE_BFRAME
+
 @end
diff --git a/sdk/objc/components/video_codec/RTCVideoEncoderH264.mm b/sdk/objc/components/video_codec/RTCVideoEncoderH264.mm
index 2160d79..b6ace41 100644
--- a/sdk/objc/components/video_codec/RTCVideoEncoderH264.mm
+++ b/sdk/objc/components/video_codec/RTCVideoEncoderH264.mm
@@ -38,6 +38,13 @@
 #include "sdk/objc/components/video_codec/nalu_rewriter.h"
 #include "third_party/libyuv/include/libyuv/convert_from.h"
 
+#ifdef RTC_ENABLE_BFRAME
+# import "base/RTCLogging.h"
+# import "deque"
+
+# define RTC_ENABLE_BFRAME_TRACE
+#endif // RTC_ENABLE_BFRAME
+
 @interface RTC_OBJC_TYPE (RTCVideoEncoderH264)
 ()
 
@@ -88,6 +95,25 @@ struct RTCFrameEncodeParams {
   uint32_t timestamp;
   RTCVideoRotation rotation;
 };
+  
+#ifdef RTC_ENABLE_BFRAME
+struct RTCEncodeQueueParams {
+  RTCEncodeQueueParams(const RTC_OBJC_TYPE(RTCVideoFrame) *frame)
+    : timestamp(frame.timeStamp)  {
+  }
+  
+  // A timestamp of RTCVideoFrame (timebase: 90KHz)
+  uint32_t timestamp;
+};
+
+# ifdef RTC_ENABLE_BFRAME_TRACE
+static const char *GetSliceTypeString(uint8_t sliceType) {
+  static const char *SLICE_TYPES[] = { "P", "B", "I", "SP", "SI", "P", "B", "I", "SP", "SI" };
+  
+  return ((sliceType < (sizeof(SLICE_TYPES) / sizeof(SLICE_TYPES[0]))) ? SLICE_TYPES[sliceType] : "N/A");
+}
+# endif // RTC_ENABLE_BFRAME_TRACE
+#endif // RTC_ENABLE_BFRAME
 
 // We receive I420Frames as input, but we need to feed CVPixelBuffers into the
 // encoder. This performs the copy and format conversion.
@@ -334,6 +360,16 @@ NSUInteger GetMaxSampleRate(const webrtc::H264ProfileLevelId &profile_level_id)
 
   webrtc::H264BitstreamParser _h264BitstreamParser;
   std::vector<uint8_t> _frameScaleBuffer;
+
+  //START:RTC_ENABLE_BFRAME
+  BOOL _bframeEnabled;
+  //END:RTC_ENABLE_BFRAME
+  
+#ifdef RTC_ENABLE_BFRAME
+  // A queue for calculating DTS order
+  std::deque<RTCEncodeQueueParams> _encodeFrameParamsQueue;
+  std::mutex _encodeFrameParamsQueueMutex;
+#endif // RTC_ENABLE_BFRAME
 }
 
 // .5 is set as a mininum to prevent overcompensating for large temporary
@@ -350,6 +386,10 @@ NSUInteger GetMaxSampleRate(const webrtc::H264ProfileLevelId &profile_level_id)
     _packetizationMode = RTCH264PacketizationModeNonInterleaved;
     _profile_level_id =
         webrtc::ParseSdpForH264ProfileLevelId([codecInfo nativeSdpVideoFormat].parameters);
+    //START:RTC_ENABLE_BFRAME
+    _bframeEnabled = NO;
+    //END:RTC_ENABLE_BFRAME
+    
     RTC_DCHECK(_profile_level_id);
     RTC_LOG(LS_INFO) << "Using profile " << CFStringToString(ExtractProfile(*_profile_level_id));
     RTC_CHECK([codecInfo.name isEqualToString:kRTCVideoCodecH264Name]);
@@ -357,6 +397,21 @@ NSUInteger GetMaxSampleRate(const webrtc::H264ProfileLevelId &profile_level_id)
   return self;
 }
 
+#ifdef RTC_ENABLE_BFRAME
+- (instancetype)initWithCodecInfo:(RTC_OBJC_TYPE(RTCVideoCodecInfo) *)codecInfo withUserSetBframeEnabled:(BOOL)bframeEnabled
+{
+  if (self = [self initWithCodecInfo:codecInfo]) {
+    _bframeEnabled = bframeEnabled;
+  }
+
+  return self;
+}
+
++ (BOOL)isBframeSupported {
+  return YES;
+}
+#endif // RTC_ENABLE_BFRAME
+
 - (void)dealloc {
   [self destroyCompressionSession];
 }
@@ -370,6 +425,13 @@ NSUInteger GetMaxSampleRate(const webrtc::H264ProfileLevelId &profile_level_id)
   _height = settings.height;
   _mode = settings.mode;
 
+#ifdef RTC_ENABLE_BFRAME
+  RTC_LOG(LS_INFO) << "[H264Encoder] bframeEnabled: " << _bframeEnabled << ", settings: " << settings.bframeEnabled;
+#endif // RTC_ENABLE_BFRAME
+  //START:RTC_ENABLE_BFRAME
+  _bframeEnabled = _bframeEnabled && settings.bframeEnabled;
+  //END:RTC_ENABLE_BFRAME
+
   uint32_t aligned_width = (((_width + 15) >> 4) << 4);
   uint32_t aligned_height = (((_height + 15) >> 4) << 4);
   _maxAllowedFrameRate = static_cast<uint32_t>(GetMaxSampleRate(*_profile_level_id) /
@@ -486,6 +548,17 @@ NSUInteger GetMaxSampleRate(const webrtc::H264ProfileLevelId &profile_level_id)
 
   // Update the bitrate if needed.
   [self setBitrateBps:_bitrateAdjuster->GetAdjustedBitrateBps() frameRate:_encoderFrameRate];
+#ifdef RTC_ENABLE_BFRAME
+  if (_bframeEnabled) {
+    {
+      std::lock_guard lockGuard(_encodeFrameParamsQueueMutex);
+      _encodeFrameParamsQueue.push_back(RTCEncodeQueueParams(frame));
+    }
+# ifdef RTC_ENABLE_BFRAME_TRACE
+    RTC_LOG(LS_VERBOSE) << "[H264Encoder] Trying to encode TS: " << frame.timeStamp;
+# endif // RTC_ENABLE_BFRAME_TRACE
+  }
+#endif // RTC_ENABLE_BFRAME
 
   OSStatus status = VTCompressionSessionEncodeFrame(_compressionSession,
                                                     pixelBuffer,
@@ -516,6 +589,12 @@ NSUInteger GetMaxSampleRate(const webrtc::H264ProfileLevelId &profile_level_id)
     return WEBRTC_VIDEO_CODEC_NO_OUTPUT;
   } else if (status != noErr) {
     RTC_LOG(LS_ERROR) << "Failed to encode frame with code: " << status;
+#ifdef RTC_ENABLE_BFRAME
+    {
+      std::lock_guard lockGuard(_encodeFrameParamsQueueMutex);
+      _encodeFrameParamsQueue.pop_back();
+    }
+#endif // RTC_ENABLE_BFRAME
     return WEBRTC_VIDEO_CODEC_ERROR;
   }
   return WEBRTC_VIDEO_CODEC_OK;
@@ -655,6 +734,24 @@ NSUInteger GetMaxSampleRate(const webrtc::H264ProfileLevelId &profile_level_id)
     RTC_LOG(LS_ERROR) << "Failed to create compression session: " << status;
     return WEBRTC_VIDEO_CODEC_ERROR;
   }
+#ifdef RTC_ENABLE_BFRAME
+#  if defined(WEBRTC_IOS)
+  if (_bframeEnabled) {
+    RTC_LOG(LS_INFO) << "[H264Encoder] Enabling kVTCompressionPropertyKey_AllowFrameReordering...";
+    SetVTSessionProperty(_compressionSession,
+                                 kVTCompressionPropertyKey_AllowFrameReordering,
+                                 true);
+
+    // status = VTSessionSetProperty(_compressionSession,
+    //                              kVTCompressionPropertyKey_NumberOfPendingFrames,
+    //                              (__bridge CFNumberRef)(@(10)));
+  } else {
+    RTC_LOG(LS_INFO) << "[H264Encoder] B-frame is disabled";
+    SetVTSessionProperty(_compressionSession, kVTCompressionPropertyKey_AllowFrameReordering, false);
+  }
+#  endif
+#endif // RTC_ENABLE_BFRAME
+
 #if defined(WEBRTC_MAC) && !defined(WEBRTC_IOS)
   CFBooleanRef hwaccl_enabled = nullptr;
   status = VTSessionCopyProperty(_compressionSession,
@@ -678,7 +775,19 @@ NSUInteger GetMaxSampleRate(const webrtc::H264ProfileLevelId &profile_level_id)
   SetVTSessionProperty(_compressionSession,
                        kVTCompressionPropertyKey_ProfileLevel,
                        ExtractProfile(*_profile_level_id));
+#ifdef RTC_ENABLE_BFRAME
+  if (_bframeEnabled) {
+    RTC_LOG(LS_INFO) << "[H264Encoder] Enabling kVTCompressionPropertyKey_AllowFrameReordering in configureCompressionSession...";
+    SetVTSessionProperty(_compressionSession,
+                                 kVTCompressionPropertyKey_AllowFrameReordering,
+                                 true);
+  } else {
+    RTC_LOG(LS_INFO) << "[H264Encoder] B-frame is disabled";
+    SetVTSessionProperty(_compressionSession, kVTCompressionPropertyKey_AllowFrameReordering, false);
+  }
+#else // RTC_ENABLE_BFRAME
   SetVTSessionProperty(_compressionSession, kVTCompressionPropertyKey_AllowFrameReordering, false);
+#endif // RTC_ENABLE_BFRAME
   [self setEncoderBitrateBps:_targetBitrateBps frameRate:_encoderFrameRate];
   // TODO(tkchin): Look at entropy mode and colorspace matrices.
   // TODO(tkchin): Investigate to see if there's any way to make this work.
@@ -700,6 +809,13 @@ NSUInteger GetMaxSampleRate(const webrtc::H264ProfileLevelId &profile_level_id)
     CFRelease(_compressionSession);
     _compressionSession = nullptr;
   }
+  
+#ifdef RTC_ENABLE_BFRAME
+  {
+    std::lock_guard lockGuard(_encodeFrameParamsQueueMutex);
+    _encodeFrameParamsQueue.clear();
+  }
+#endif // RTC_ENABLE_BFRAME
 }
 
 - (NSString *)implementationName {
@@ -801,8 +917,12 @@ NSUInteger GetMaxSampleRate(const webrtc::H264ProfileLevelId &profile_level_id)
   frame.encodedWidth = width;
   frame.encodedHeight = height;
   frame.frameType = isKeyframe ? RTCFrameTypeVideoFrameKey : RTCFrameTypeVideoFrameDelta;
+#ifdef RTC_ENABLE_BFRAME
+  // frame.captureTimeMs and frame.timeStamp will be set in the below code
+#else // RTC_ENABLE_BFRAME
   frame.captureTimeMs = renderTimeMs;
   frame.timeStamp = timestamp;
+#endif
   frame.rotation = rotation;
   frame.contentType = (_mode == RTCVideoCodecModeScreensharing) ? RTCVideoContentTypeScreenshare :
                                                                   RTCVideoContentTypeUnspecified;
@@ -810,6 +930,38 @@ NSUInteger GetMaxSampleRate(const webrtc::H264ProfileLevelId &profile_level_id)
 
   _h264BitstreamParser.ParseBitstream(*buffer);
   frame.qp = @(_h264BitstreamParser.GetLastSliceQp().value_or(-1));
+  
+#ifdef RTC_ENABLE_BFRAME
+  frame.captureTimeMs = renderTimeMs;
+  frame.timeStamp = timestamp;
+  
+  if (_bframeEnabled) {
+    {
+      std::lock_guard lockGuard(_encodeFrameParamsQueueMutex);
+      
+      if (_encodeFrameParamsQueue.empty()) {
+        RTC_LOG(LS_ERROR) << "[H264Encoder] _encodeFrameParamsQueue is empty";
+        frame.dts = @(frame.timeStamp);
+      } else {
+        // Use the timestamp as DTS
+        const auto params = _encodeFrameParamsQueue.front();
+        _encodeFrameParamsQueue.pop_front();
+        frame.dts = @(params.timestamp);
+      }
+    }
+    
+    const uint8_t sliceType = _h264BitstreamParser.GetLastSliceType().value_or(0xff);
+    frame.isBframe = @(sliceType == webrtc::H264::SliceType::kB);
+    
+# ifdef RTC_ENABLE_BFRAME_TRACE
+    RTC_LOG(LS_VERBOSE)
+    << "[H264Encoder] Frame is encoded: timeStamp: " << frame.timeStamp
+    << ", DTS: " << frame.dts.unsignedIntValue
+    << ", captureTimeMs(PTS): " << frame.captureTimeMs
+    << ", " << GetSliceTypeString(sliceType) << " (" << sliceType << ")";
+# endif // RTC_ENABLE_BFRAME_TRACE
+  }
+#endif // RTC_ENABLE_BFRAME
 
   BOOL res = callback(frame, codecSpecificInfo);
   if (!res) {
diff --git a/sdk/objc/components/video_codec/RTCVideoEncoderH265.h b/sdk/objc/components/video_codec/RTCVideoEncoderH265.h
index 7305e76..1f54f2c 100644
--- a/sdk/objc/components/video_codec/RTCVideoEncoderH265.h
+++ b/sdk/objc/components/video_codec/RTCVideoEncoderH265.h
@@ -21,4 +21,14 @@ RTC_OBJC_EXPORT
 - (void)setLowLatency:(bool)enabled;
 - (void)setUseAnnexB:(bool)useAnnexB;
 - (void)flush;
+
+#ifdef RTC_ENABLE_BFRAME
+- (instancetype)initWithCodecInfo:(RTC_OBJC_TYPE(RTCVideoCodecInfo) *)codecInfo withUserSetBframeEnabled:(BOOL)bframeEnabled;
++ (BOOL)isBframeSupported;
+#endif // RTC_ENABLE_BFRAME
+
+//START:RTC_ENABLE_BFRAME
+@property (nonatomic, assign) BOOL bframeEnabled;
+//END:RTC_ENABLE_BFRAME
+
 @end
diff --git a/sdk/objc/components/video_codec/RTCVideoEncoderH265.mm b/sdk/objc/components/video_codec/RTCVideoEncoderH265.mm
index ed95a7c..a4927f5 100644
--- a/sdk/objc/components/video_codec/RTCVideoEncoderH265.mm
+++ b/sdk/objc/components/video_codec/RTCVideoEncoderH265.mm
@@ -36,6 +36,14 @@
 #include "sdk/objc/Framework/Classes/VideoToolbox/nalu_rewriter.h"
 #include "system_wrappers/include/clock.h"
 
+#ifdef RTC_ENABLE_BFRAME
+# import "common_video/h265/h265_bitstream_parser.h"
+# import "base/RTCLogging.h"
+# import "deque"
+
+# define RTC_ENABLE_BFRAME_TRACE
+#endif // RTC_ENABLE_BFRAME
+
 @interface RTC_OBJC_TYPE (RTCVideoEncoderH265) ()
 
 - (void)frameWasEncoded:(OSStatus)status
@@ -84,6 +92,25 @@ struct API_AVAILABLE(ios(11.0)) RTCFrameEncodeParams {
   RTCVideoRotation rotation;
 };
 
+#ifdef RTC_ENABLE_BFRAME
+struct RTCEncodeQueueParams {
+  RTCEncodeQueueParams(const uint32_t timestamp)
+    : timestamp(timestamp)  {
+  }
+  
+  // A timestamp (timebase: 90KHz)
+  uint32_t timestamp;
+};
+#endif // RTC_ENABLE_BFRAME
+
+#ifdef RTC_ENABLE_BFRAME_TRACE
+static const char *GetSliceTypeString(uint8_t sliceType) {
+  static const char *SLICE_TYPES[] = { "B", "P", "I" };
+  
+  return ((sliceType < (sizeof(SLICE_TYPES) / sizeof(SLICE_TYPES[0]))) ? SLICE_TYPES[sliceType] : "N/A");
+}
+#endif // RTC_ENABLE_BFRAME_TRACE
+
 // We receive I420Frames as input, but we need to feed CVPixelBuffers into the
 // encoder. This performs the copy and format conversion.
 // TODO(tkchin): See if encoder will accept i420 frames and compare performance.
@@ -177,6 +204,18 @@ void compressionOutputCallback(void* encoder,
   std::vector<uint8_t> _nv12ScaleBuffer;
   bool _useAnnexB;
   bool _isLowLatencyEnabled;
+  
+  //START:RTC_ENABLE_BFRAME
+  BOOL _bframeEnabled;
+  //END:RTC_ENABLE_BFRAME
+  
+#ifdef RTC_ENABLE_BFRAME
+  webrtc::H265BitstreamParser _h265BitstreamParser;
+  
+  // A queue for calcuating DTS order
+  std::deque<RTCEncodeQueueParams> _encodeFrameParamsQueue;
+  std::mutex _encodeFrameParamsQueueMutex;
+#endif // RTC_ENABLE_BFRAME
 }
 
 // .5 is set as a mininum to prevent overcompensating for large temporary
@@ -192,12 +231,31 @@ void compressionOutputCallback(void* encoder,
     _bitrateAdjuster.reset(new webrtc::BitrateAdjuster(.5, .95));
     _useAnnexB = true;
     _isLowLatencyEnabled = true;
+    //START:RTC_ENABLE_BFRAME
+    _bframeEnabled = NO;
+    //END:RTC_ENABLE_BFRAME
+    
     RTC_CHECK([codecInfo.name isEqualToString:@"H265"]);
   }
 
   return self;
 }
 
+#ifdef RTC_ENABLE_BFRAME
+- (instancetype)initWithCodecInfo:(RTC_OBJC_TYPE(RTCVideoCodecInfo) *)codecInfo withUserSetBframeEnabled:(BOOL)bframeEnabled
+{
+  if (self = [self initWithCodecInfo:codecInfo]) {
+    _bframeEnabled = bframeEnabled;
+  }
+
+  return self;
+}
+
++ (BOOL)isBframeSupported {
+  return YES;
+}
+#endif // RTC_ENABLE_BFRAME
+
 - (void)dealloc {
   [self destroyCompressionSession];
 }
@@ -211,6 +269,13 @@ void compressionOutputCallback(void* encoder,
   _height = settings.height;
   _mode = settings.mode;
 
+#ifdef RTC_ENABLE_BFRAME
+  RTC_LOG(LS_INFO) << "[H265Encoder] bframeEnabled: " << _bframeEnabled << ", settings: " << settings.bframeEnabled;
+#endif // RTC_ENABLE_BFRAME
+  //START:RTC_ENABLE_BFRAME
+  _bframeEnabled = _bframeEnabled && settings.bframeEnabled;
+  //END:RTC_ENABLE_BFRAME
+
   // We can only set average bitrate on the HW encoder.
   _targetBitrateBps = settings.startBitrate;
   _bitrateAdjuster->SetTargetBitrateBps(_targetBitrateBps);
@@ -334,6 +399,21 @@ void compressionOutputCallback(void* encoder,
   // Update the bitrate if needed.
   [self setBitrateBps:_bitrateAdjuster->GetAdjustedBitrateBps()];
 
+#ifdef RTC_ENABLE_BFRAME
+  if (_bframeEnabled) {
+    {
+      std::lock_guard lockGuard(_encodeFrameParamsQueueMutex);
+      _encodeFrameParamsQueue.push_back(RTCEncodeQueueParams(encodeParams->timestamp));
+    }
+    
+# ifdef RTC_ENABLE_BFRAME_TRACE
+    RTC_LOG(LS_VERBOSE)
+    << "[H265Encoder] Trying to encode TS: " << static_cast<uint32_t>(frame.timeStamp)
+    << " (" << frame.timeStamp << ")";
+# endif // RTC_ENABLE_BFRAME_TRACE
+  }
+#endif // RTC_ENABLE_BFRAME
+  
   OSStatus status = VTCompressionSessionEncodeFrame(
       _compressionSession, pixelBuffer, presentationTimeStamp, kCMTimeInvalid,
       frameProperties, encodeParams.release(), nullptr);
@@ -345,6 +425,12 @@ void compressionOutputCallback(void* encoder,
   }
   if (status != noErr) {
     RTC_LOG(LS_ERROR) << "Failed to encode frame with code: " << status;
+#ifdef RTC_ENABLE_BFRAME
+    {
+      std::lock_guard lockGuard(_encodeFrameParamsQueueMutex);
+      _encodeFrameParamsQueue.pop_back();
+    }
+#endif // RTC_ENABLE_BFRAME
     return WEBRTC_VIDEO_CODEC_ERROR;
   }
   return WEBRTC_VIDEO_CODEC_OK;
@@ -447,6 +533,19 @@ void compressionOutputCallback(void* encoder,
     RTC_LOG(LS_ERROR) << "Failed to create compression session: " << status;
     return WEBRTC_VIDEO_CODEC_ERROR;
   }
+#ifdef RTC_ENABLE_BFRAME
+#  if defined(WEBRTC_IOS)
+  if (_bframeEnabled) {
+    RTC_LOG(LS_INFO) << "[H265Encoder] Enabling kVTCompressionPropertyKey_AllowFrameReordering...";
+    SetVTSessionProperty(_compressionSession,
+                                 kVTCompressionPropertyKey_AllowFrameReordering,
+                                 true);
+  } else {
+    RTC_LOG(LS_INFO) << "[H265Encoder] B-frame is disabled";
+  }
+#  endif
+#endif // RTC_ENABLE_BFRAME
+
 #if defined(WEBRTC_MAC) && !defined(WEBRTC_IOS)
   CFBooleanRef hwaccl_enabled = nullptr;
   status = VTSessionCopyProperty(
@@ -469,7 +568,19 @@ void compressionOutputCallback(void* encoder,
                        _isLowLatencyEnabled);
   // SetVTSessionProperty(_compressionSession,
   // kVTCompressionPropertyKey_ProfileLevel, _profile);
+#ifdef RTC_ENABLE_BFRAME
+  if (_bframeEnabled) {
+    RTC_LOG(LS_INFO) << "[H265Encoder] Enabling kVTCompressionPropertyKey_AllowFrameReordering in configureCompressionSession...";
+    SetVTSessionProperty(_compressionSession,
+                                 kVTCompressionPropertyKey_AllowFrameReordering,
+                                 true);
+  } else {
+    RTC_LOG(LS_INFO) << "[H265Encoder] B-frame is disabled";
+    SetVTSessionProperty(_compressionSession, kVTCompressionPropertyKey_AllowFrameReordering, false);
+  }
+#else // RTC_ENABLE_BFRAME
   SetVTSessionProperty(_compressionSession, kVTCompressionPropertyKey_AllowFrameReordering, false);
+#endif // RTC_ENABLE_BFRAME
   [self setEncoderBitrateBps:_targetBitrateBps];
 
   // Set a relatively large value for keyframe emission (7200 frames or 4 minutes).
@@ -488,6 +599,13 @@ void compressionOutputCallback(void* encoder,
     CFRelease(_compressionSession);
     _compressionSession = nullptr;
   }
+  
+#ifdef RTC_ENABLE_BFRAME
+  {
+    std::lock_guard lockGuard(_encodeFrameParamsQueueMutex);
+    _encodeFrameParamsQueue.clear();
+  }
+#endif // RTC_ENABLE_BFRAME
 }
 
 - (NSString*)implementationName {
@@ -598,14 +716,51 @@ void compressionOutputCallback(void* encoder,
   frame.encodedHeight = height;
   frame.frameType =
       isKeyframe ? RTCFrameTypeVideoFrameKey : RTCFrameTypeVideoFrameDelta;
+#ifdef RTC_ENABLE_BFRAME
+  // frame.captureTimeMs and frame.timeStamp will be set in the below code
+#else // RTC_ENABLE_BFRAME
   frame.captureTimeMs = renderTimeMs;
   frame.timeStamp = timestamp;
+#endif // RTC_ENABLE_BFRAME
   frame.rotation = rotation;
   frame.contentType = (_mode == RTCVideoCodecModeScreensharing)
                           ? RTCVideoContentTypeScreenshare
                           : RTCVideoContentTypeUnspecified;
   frame.flags = webrtc::VideoSendTiming::kInvalid;
 
+#ifdef RTC_ENABLE_BFRAME
+  _h265BitstreamParser.ParseBitstream(*buffer);
+  frame.qp = @(_h265BitstreamParser.GetLastSliceQp().value_or(-1));
+  frame.captureTimeMs = renderTimeMs;
+  frame.timeStamp = timestamp;
+  
+  if (_bframeEnabled) {
+    {
+      std::lock_guard lockGuard(_encodeFrameParamsQueueMutex);
+      
+      if(_encodeFrameParamsQueue.empty()) {
+        RTC_LOG(LS_ERROR) << "_encodeFrameParamsQueue is empty";
+        frame.dts = @(frame.timeStamp);
+      } else {
+        // Use the timestamp as DTS
+        const auto params = _encodeFrameParamsQueue.front();
+        _encodeFrameParamsQueue.pop_front();
+        frame.dts = @(params.timestamp);
+      }
+    }
+    
+    const uint8_t sliceType = _h265BitstreamParser.GetLastSliceType().value_or(0xff);
+    frame.isBframe = @(sliceType == webrtc::H265::SliceType::kB);
+    
+# ifdef RTC_ENABLE_BFRAME_TRACE
+    RTC_LOG(LS_VERBOSE)
+    << "[H265Encoder] Frame is encoded: timeStamp: " << frame.timeStamp
+    << ", DTS: " << frame.dts.unsignedIntValue
+    << ", captureTimeMs(PTS): " << frame.captureTimeMs
+    << ", " << GetSliceTypeString(sliceType) << " (" << sliceType << ")";
+# endif // RTC_ENABLE_BFRAME_TRACE
+  }
+#endif // RTC_ENABLE_BFRAME
   // FIXME: QP is ignored because there is no H.265 bitstream parser.
 
   BOOL res = _callback(frame, [[RTC_OBJC_TYPE(RTCCodecSpecificInfoH265) alloc] init]);
diff --git a/sdk/objc/components/video_codec/ts_rollover_helper.h b/sdk/objc/components/video_codec/ts_rollover_helper.h
new file mode 100644
index 0000000..299fc74
--- /dev/null
+++ b/sdk/objc/components/video_codec/ts_rollover_helper.h
@@ -0,0 +1,55 @@
+#ifndef SDK_OBJC_FRAMEWORK_CLASSES_VIDEOTOOLBOX_TS_ROLLOVER_HELPER_H_
+#define SDK_OBJC_FRAMEWORK_CLASSES_VIDEOTOOLBOX_TS_ROLLOVER_HELPER_H_
+
+class TsRolloverHelper {
+public:
+  uint32_t UpdateTs(const uint32_t ts, bool * const isRolled = nullptr) {
+    constexpr int64_t MAX_ROLLOVER_VALUE = UINT32_MAX;
+    bool rolled = false;
+    const uint32_t lastTs = lastTs_;
+    lastTs_ = ts;
+    
+    // Check whether PTS is rolled
+    if (isFirstTs_ == false) {
+      int64_t dTs = ts - lastTs;
+      
+      if (dTs >= (MAX_ROLLOVER_VALUE / 2)) {
+        dTs -= (MAX_ROLLOVER_VALUE + 1);
+      } else if (dTs <= (-1 * (MAX_ROLLOVER_VALUE / 2))) {
+        dTs += (MAX_ROLLOVER_VALUE + 1);
+        rolled = true;
+      }
+      
+      ts_ += dTs;
+    } else {
+      ts_ = ts;
+      isFirstTs_ = false;
+    }
+    
+    if (isRolled != nullptr) {
+      *isRolled = rolled;
+    }
+    
+    return lastTs;
+  }
+  
+  int64_t CurrentTs() const {
+    return ts_;
+  }
+  
+  void Reset() {
+    isFirstTs_ = true;
+    lastTs_ = INT64_MIN;
+    ts_ = INT64_MIN;
+  }
+  
+private:
+  bool isFirstTs_ = true;
+  
+  // The maximum TS value since the last rolling
+  int64_t lastTs_ = INT64_MIN;
+  // Total accumulated TS increase so far
+  int64_t ts_ = INT64_MIN;
+};
+
+#endif // SDK_OBJC_FRAMEWORK_CLASSES_VIDEOTOOLBOX_TS_ROLLOVER_HELPER_H_
